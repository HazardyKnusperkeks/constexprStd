/**
 ** This file is part of the constexprStd project.
 ** Copyright 2017 Björn Schäpers <bjoern@hazardy.de>.
 **
 ** This program is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as
 ** published by the Free Software Foundation, either version 3 of the
 ** License, or (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file
 * @brief Contains the constexpr variants of <iterator>
 */

#ifndef CONSTEXPRSTD_ITERATOR
#define CONSTEXPRSTD_ITERATOR

#include <iterator>
#include <type_traits>

namespace constexprStd {

template<typename Container>
class insert_iterator {
	private:
	using IterType   = typename Container::iterator;
	using CValueType = typename Container::value_type;
	
	protected:
	Container *C;
	IterType Iter;
	
	public:
	using value_type 		= void;
	using difference_type 	= void;
	using pointer 			= void;
	using reference         = void;
	using iterator_category = std::output_iterator_tag;
	using container_type    = Container;
	
	constexpr insert_iterator(Container& c, IterType iter) noexcept(std::is_nothrow_move_constructible_v<IterType>) :
			C{std::addressof(c)}, Iter{std::move(iter)} {
		return;
	}
	
	constexpr insert_iterator& operator=(const CValueType& value)
			noexcept(noexcept(Iter = C->insert(Iter, value)) && noexcept(++Iter)) {
		Iter = C->insert(Iter, value);
		++Iter;
		return *this;
	}
	
	constexpr insert_iterator& operator=(CValueType&& value)
			noexcept(noexcept(Iter = C->insert(Iter, std::move(value))) && noexcept(++Iter)) {
		Iter = C->insert(Iter, std::move(value));
		++Iter;
		return *this;
	}
	
	constexpr insert_iterator& operator*(void) noexcept {
		return *this;
	}
	
	constexpr insert_iterator& operator++(void) noexcept {
		return *this;
	}
	
	constexpr insert_iterator& operator++(const int) noexcept {
		return *this;
	}
};

template<typename Container>
constexpr insert_iterator<Container> inserter(Container& c, const typename Container::iterator iter)
		noexcept(std::is_nothrow_constructible_v<insert_iterator<Container>, Container&,
		                                         const typename Container::iterator>) {
	return {c, iter};
}

} //namespace constexprStd

#endif
