/**
 ** This file is part of the constexprStd project.
 ** Copyright 2017 Björn Schäpers <bjoern@hazardy.de>.
 **
 ** This program is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as
 ** published by the Free Software Foundation, either version 3 of the
 ** License, or (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file
 * @brief Contains the constexpr variants of <set>
 */

#ifndef CONSTEXPRSTD_SET
#define CONSTEXPRSTD_SET

#include <iterator>
#include <memory>

#include "details/set.hpp"
#include "memory"

namespace constexprStd {
template<typename Key, std::size_t N, typename Compare,
         template<typename, std::size_t> typename Allocator,
         typename NodeType = details::SetNode<Key>, std::size_t AllocN = N>
class set_base {
	public:
	using key_type               = Key;
	using value_type             = Key;
	using iterator               = details::SetNodeIterator<Key>;
	using const_iterator         = details::SetNodeIterator<Key>;
	using size_type              = std::size_t;
	using difference_type        = std::ptrdiff_t;
	using key_compare            = Compare;
	using value_compare          = Compare;
	using allocator_type         = Allocator<NodeType, AllocN>;
	using reference              = value_type&;
	using const_reference        = const value_type&;
	using pointer                = value_type*;
	using const_pointer          = const value_type*;
	using reverse_iterator       = std::reverse_iterator<iterator>;
	using const_reverse_iterator = std::reverse_iterator<const_iterator>;
	
	using CmpIsNoexcept       = std::bool_constant<noexcept(std::declval<Compare&>()(std::declval<const key_type&>(),
	                                                                                 std::declval<const key_type&>()))>;
	using AllocIsNoexcept     = std::bool_constant<noexcept(std::declval<allocator_type&>().allocate(1))>;
	using DestroyIsNoexcept   = std::bool_constant<
		noexcept(std::declval<allocator_type&>().destroy(std::declval<NodeType*>()))>;
	template<typename... Args>
	using CreateIsNoexcept = std::bool_constant<
		noexcept(std::declval<allocator_type&>().construct(std::declval<NodeType*>(), std::declval<Args&&>()...))>;
	template<typename T>
	using InsertIsNoexcept = std::bool_constant<CreateIsNoexcept<details::NodeTag, T&&>::value>;
	
	private:
	allocator_type& Alloc;
	NodeType End{};
	NodeType *Root = &End;
	size_type Nodes = 0;
	value_compare Cmp;
	
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNode(const value_type& value, NodeType *hintNode) const
			noexcept(CmpIsNoexcept::value) {
		if ( hintNode != Root ) {
			if ( Cmp(value, hintNode->getContent()) ) {
				if ( auto prev = hintNode->prev(); prev && Cmp(value, prev->getContent()) ) {
					hintNode = Root;
				} //if ( auto prev = hintNode->prev(); prev && Cmp(value, prev->getContent()) )
			} //if ( Cmp(value, hintNode->getContent()) )
			else {
				if ( auto next = hintNode->next(); next && !Cmp(value, next->getContent()) ) {
					hintNode = Root;
				} //if ( auto next = hintNode->next(); next && !Cmp(value, next->getContent()) )
			} //else -> if ( Cmp(value, hintNode->getContent()) )
		} //if ( hintNode != Root )
		return findBestNode(hintNode, value);
	}
	
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNode(NodeType *node, const value_type& value) const
			noexcept(CmpIsNoexcept::value) {
		if ( Cmp(value, node->getContent()) ) {
			return findBestNodeLeft(node, value);
		} //if ( Cmp(value, node->getContent()) )
		if ( Cmp(node->getContent(), value) ) {
			return findBestNodeRight(node, value);
		} //if ( Cmp(node->getContent(), value) )
		//The value is equal to the value of node
		return {node, true};
	}
	
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNodeLeft(NodeType *node, const value_type& value)
			const noexcept(CmpIsNoexcept::value) {
		if ( !node->hasLeftChild() ) {
			return {node, false};
		} //if ( !node->hasLeftChild() )
		return findBestNode(node->LeftChild, value);
	}
	
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNodeRight(NodeType *node, const value_type& value)
			const noexcept(CmpIsNoexcept::value) {
		if ( !node->hasRightChild() || node->RightChild == &End ) {
			return {node, false};
		} //if ( !node->hasRightChild() || node->RightChild == &End )
		return findBestNode(node->RightChild, value);
	}
	
	template<typename... Args>
	[[nodiscard]] constexpr NodeType* createNode(Args&&... args)
			noexcept(AllocIsNoexcept::value && CreateIsNoexcept<details::NodeTag, Args&&...>::value) {
		NodeType *ret = Alloc.allocate(1);
		Alloc.construct(ret, details::NodeTag{}, std::forward<Args>(args)...);
		return ret;
	}
	
	constexpr void destroyNodeRecursive(NodeType *node) noexcept(DestroyIsNoexcept::value) {
		if ( node == nullptr ) {
			return;
		} //if ( node == nullptr )
		destroyNodeRecursive(node->LeftChild);
		destroyNodeRecursive(node->RightChild);
		destroyNode(node);
		return;
	}
	
	constexpr void destroyNode(NodeType *node) noexcept(DestroyIsNoexcept::value) {
		node->reset();
		Alloc.destroy(node);
		Alloc.deallocate(node, 1);
		return;
	}
	
	template<typename T>
	[[nodiscard]] constexpr std::pair<iterator, bool> insertImpl(NodeType *hintNode, T&& value)
			noexcept(CmpIsNoexcept::value && InsertIsNoexcept<T&&>::value) {
		std::pair<NodeType*, bool> result = findBestNode(value, hintNode);
		NodeType *node = result.first;
		if ( result.second ) {
			return {node, false};
		} //if ( result.second )
		
		auto newNode = createNode(std::forward<T>(value));
		++Nodes;
		if ( Cmp(newNode->getContent(), node->getContent()) ) {
			node->adoptLeft(newNode);
		} //if ( Cmp(newNode->getContent(), node->getContent()) )
		else {
			const bool adaptEnd = node->isRightChild(&End);
			if ( adaptEnd ) {
				End.markForAdoption();
			} //if ( adaptEnd )
			node->adoptRight(newNode);
			if ( adaptEnd ) {
				newNode->adoptRight(&End);
			} //if ( adaptEnd )
		} //else -> if ( Cmp(newNode->getContent(), node->getContent()) )
		rebalanceTreeAfterInsert(newNode);
		return {newNode, true};
	}
	
	template<typename T>
	constexpr void insertRoot(T&& value) noexcept(InsertIsNoexcept<T&&>::value) {
		Root = createNode(std::forward<T>(value));
		Root->adoptRight(&End);
		Root->Color = details::NodeColor::Black;
		Nodes = 1;
		return;
	}
	
	constexpr void rotateLeft(NodeType *parent, NodeType *child) noexcept {
		child->markForAdoption();
		
		if ( auto leftGrandchild = child->LeftChild; leftGrandchild ) {
			leftGrandchild->markForAdoption();
			parent->adoptRight(leftGrandchild);
		} //if ( auto leftGrandchild = child->LeftChild; leftGrandchild )
		
		auto grandparent = parent->Parent;
		auto dir = parent->markForAdoption();
		child->adoptLeft(parent);
		if ( grandparent ) {
			grandparent->adopt(child, dir);
		} //if ( grandparent )
		return;
	}
	
	constexpr void rotateRight(NodeType *parent, NodeType *child) noexcept {
		child->markForAdoption();
		
		if ( auto rightGrandchild = child->RightChild; rightGrandchild ) {
			rightGrandchild->markForAdoption();
			parent->adoptLeft(rightGrandchild);
		} //if ( auto rightGrandchild = child->RightChild; rightGrandchild )
		
		auto grandparent = parent->Parent;
		auto dir = parent->markForAdoption();
		child->adoptRight(parent);
		if ( grandparent ) {
			grandparent->adopt(child, dir);
		} //if ( grandparent )
		return;
	}
	
	constexpr void rebalanceTreeAfterInsert(NodeType *node) noexcept {
		//Cases according to german wikipedia
		//Case 1: Node has no parent, it is the root, is has to be black!
		auto parent = node->Parent;
		if ( !parent ) {
			node->Color = details::NodeColor::Black;
			return;
		} //if ( !parent )
		
		//Case 2: Parent is black, everything is fine
		if ( parent->Color == details::NodeColor::Black ) {
			return;
		} //if ( parent->Color == details::NodeColor::Black )
		
		//Now we know the parent is red, so itself has a parent, there exists a grandparent
		auto grandparent = parent->Parent;
		//And possibly an uncle
		auto uncle = grandparent->otherChild(parent);
		if ( uncle == &End ) {
			uncle = nullptr;
		} //if ( uncle == &End )
		
		//Case 3: Parent and uncle are red
		if ( uncle && uncle->Color == details::NodeColor::Red ) {
			//Switch color from parent, uncle, and grandparent and and restart at the grandparent
			parent->Color = uncle->Color = details::NodeColor::Black;
			grandparent->Color = details::NodeColor::Red;
			rebalanceTreeAfterInsert(grandparent);
			return;
		} //if ( uncle && uncle->Color == details::NodeColor::Red )
		
		//Case 4: If there is an uncle he is black, node and parent are black, the grandparent is black
		//Case 4a: The parent is the left child and node is the right child
		if ( parent->isRightChild(node) && grandparent->isLeftChild(parent) ) {
			//Rotate left from parent and node
			rotateLeft(parent, node);
			//Change the names and continue with case 5
			constexprStd::swap(parent, node);
		} //if ( parent->isRightChild(node) && grandparent->isLeftChild(parent) )
		//Case 4b: Change left and right
		else if ( parent->isLeftChild(node) && grandparent->isRightChild(parent) ) {
			rotateRight(parent, node);
			constexprStd::swap(parent, node);
		} //else if ( parent->isLeftChild(node) && grandparent->isRightChild(parent) )
		
		//Case 5: The uncle is still black, as is the grandparent, node and parent are still red
		if ( grandparent->isLeftChild(parent) ) {
			rotateRight(grandparent, parent);
		} //if ( grandparent->isLeftChild(parent) )
		else {
			rotateLeft(grandparent, parent);
		} //else -> if ( grandparent->isLeftChild(parent) )
		//After rotation change colors of parent and grandparent (which is now a son of parent, weird or?)
		parent->Color = details::NodeColor::Black;
		grandparent->Color = details::NodeColor::Red;
		
		if ( grandparent == Root ) {
			//Update the root, if neccessary.
			Root = parent;
		} //if ( grandparent == Root )
		return;
	}
	
	[[nodiscard]] constexpr bool checkBlackDepth(const NodeType *node, int blackToGo) const noexcept {
		if ( !node ) {
			return blackToGo == 0;
		} //if ( !node )
		
		if ( node->Color == details::NodeColor::Black ) {
			if ( --blackToGo == -1 ) {
				return false;
			} //if ( --blackToGo == -1 )
		} //if ( node->Color == details::NodeColor::Black )
		
		return checkBlackDepth(node->LeftChild, blackToGo) && checkBlackDepth(node->RightChild, blackToGo);
	}
	
	[[nodiscard]] constexpr bool checkBinarySearchTree(const NodeType *node) const noexcept {
		auto left  = node->LeftChild;
		auto right = node->RightChild;
		
		if ( right == &End ) {
			right = nullptr;
		} //if ( right == &End )
		
		if ( left ) {
			if ( !Cmp(left->getContent(), node->getContent()) ) {
				return false;
			} //if ( !Cmp(left->getContent(), node->getContent()) )
			if ( !checkBinarySearchTree(left) ) {
				return false;
			} //if ( !checkBinarySearchTree(left) )
		} //if ( left )
		
		if ( right ) {
			if ( !Cmp(node->getContent(), right->getContent()) ) {
				return false;
			} //if ( !Cmp(node->getContent(), right->getContent()) )
			if ( !checkBinarySearchTree(right) ) {
				return false;
			} //if ( !checkBinarySearchTree(right) )
		} //if ( right )
		
		return true;
	}
	
	public:
	explicit constexpr set_base(allocator_type& alloc) noexcept : set_base{Compare{}, alloc} {
		return;
	}
	
	explicit constexpr set_base(Compare cmp, allocator_type& alloc) noexcept : Alloc{alloc}, Cmp{std::move(cmp)} {
		return;
	}
	
	[[nodiscard]] constexpr iterator begin(void) noexcept {
		return Root->leftestNode();
	}
	
	[[nodiscard]] constexpr const_iterator begin(void) const noexcept {
		return Root->leftestNode();
	}
	
	[[nodiscard]] constexpr iterator end(void) noexcept {
		return &End;
	}
	
	[[nodiscard]] constexpr const_iterator end(void) const noexcept {
		return &End;
	}
	
	[[nodiscard]] constexpr const_iterator cbegin(void) const noexcept {
		return Root->leftestNode();
	}
	
	[[nodiscard]] constexpr const_iterator cend(void) const noexcept {
		return &End;
	}
	
	[[nodiscard]] constexpr reverse_iterator rbegin(void) noexcept {
		return std::make_reverse_iterator(end());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator rbegin(void) const noexcept {
		return std::make_reverse_iterator(end());
	}
	
	[[nodiscard]] constexpr reverse_iterator rend(void) noexcept {
		return std::make_reverse_iterator(begin());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator rend(void) const noexcept {
		return std::make_reverse_iterator(begin());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator crbegin(void) const noexcept {
		return std::make_reverse_iterator(end());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator crend(void) const noexcept {
		return std::make_reverse_iterator(begin());
	}
	
	[[nodiscard]] constexpr bool empty(void) const noexcept {
		return Nodes == 0;
	}
	
	[[nodiscard]] constexpr size_type size(void) const noexcept {
		return Nodes;
	}
	
	constexpr void clear(void) noexcept(DestroyIsNoexcept::value) {
		if ( empty() ) {
			return;
		} //if ( empty() )
		End.markForAdoption();
		destroyNodeRecursive(Root);
		Root = &End;
		Nodes = 0;
		return;
	}
	
	constexpr std::pair<iterator, bool> insert(const value_type& value)
			noexcept(CmpIsNoexcept::value && InsertIsNoexcept<const value_type&>::value) {
		if ( empty() ) {
			insertRoot(value);
			return {Root, true};
		} //if ( empty() )
		
		auto ret = insertImpl(Root, value);
		return ret;
	}
	
	constexpr std::pair<iterator, bool> insert(value_type&& value)
			noexcept(CmpIsNoexcept::value && InsertIsNoexcept<value_type&&>::value) {
		if ( empty() ) {
			insertRoot(std::move(value));
			return {Root, true};
		} //if ( empty() )
		
		auto ret = insertImpl(Root, std::move(value));
		return ret;
	}
	
	constexpr iterator insert(const_iterator hint, const value_type& value)
			noexcept(CmpIsNoexcept::value && InsertIsNoexcept<const value_type&>::value) {
		if ( empty() ) {
			insertRoot(value);
			return Root;
		} //if ( empty() )
		
		NodeType *hintNode = hint.Node == &End ? End.Parent : hint.Node;
		auto ret = insertImpl(hintNode, value);
		return ret.first;
	}
	
	constexpr iterator insert(const_iterator hint, value_type&& value)
			noexcept(CmpIsNoexcept::value && InsertIsNoexcept<value_type&&>::value) {
		if ( empty() ) {
			insertRoot(std::move(value));
			return Root;
		} //if ( empty() )
		
		NodeType *hintNode = hint.Node == &End ? End.Parent : hint.Node;
		auto ret = insertImpl(hintNode, std::move(value));
		return ret.first;
	}
	
	template<typename InputIter>
	constexpr void insert(InputIter first, const InputIter last)
		noexcept(noexcept(first == last) && CmpIsNoexcept::value && InsertIsNoexcept<const value_type&>::value &&
		         noexcept(*first) && noexcept(++first) && noexcept(first != last) &&
		         std::is_nothrow_copy_assignable_v<iterator>) {
		if ( empty() ) {
			if ( first == last ) {
				return;
			} //if ( first == last )
			
			insertRoot(*first);
			++first;
		} //if ( empty() )
		
		iterator hint = End.Parent;
		for ( ; first != last; ++first ) {
			hint = insert(hint, *first);
		} //for ( ; first != last; ++first )
		return;
	}
	
	[[nodiscard]] constexpr bool checkBlackDepth(void) const noexcept {
		if ( empty() ) {
			return true;
		} //if ( empty() )
		
		if ( Root->Color == details::NodeColor::Red ) {
			return false;
		} //if ( Root->Color == details::NodeColor::Red )
		
		int blackCount = 1;
		for ( NodeType *node = Root->LeftChild; node; node = node->LeftChild ) {
			if ( node->Color == details::NodeColor::Black ) {
				++blackCount;
			} //if ( node->Color == details::NodeColor::Black )
		} //for ( NodeType *node = Root->LeftChild; node; node = node->LeftChild )
		
		return checkBlackDepth(Root, blackCount);
	}
	
	[[nodiscard]] constexpr bool checkBinarySearchTree(void) const noexcept {
		if ( empty() ) {
			return true;
		} //if ( empty() )
		
		return checkBinarySearchTree(Root);
	}
};

template<typename Key, std::size_t N, typename Compare = std::less<Key>,
         template<typename, std::size_t> typename Allocator = constexprStd::allocator>
class set : public set_base<Key, N, Compare, Allocator> {
	private:
	using Base = set_base<Key, N, Compare, Allocator>;
	
	typename Base::allocator_type Alloc;
	
	public:
	constexpr set(void) noexcept : Base{Alloc} {
		return;
	}
};

template<typename Key, std::size_t N, typename Compare = std::less<Key>,
         template<typename, std::size_t> typename Allocator = constexprStd::allocator>
class setDestroy : public set<Key, N, Compare, Allocator> {
	private:
	using Base = set<Key, N, Compare, Allocator>;
	
	public:
	constexpr setDestroy(void) noexcept = default;
	
	template<typename... Args>
	explicit constexpr setDestroy(Args&&... args) noexcept(std::is_nothrow_constructible_v<Base, Args&&...>) :
			Base{std::forward<Args>(args)...} {
		return;
	}
	
	~setDestroy(void) noexcept(noexcept(std::declval<Base&>().clear())) {
		Base::clear();
		return;
	}
};
} //namespace constexprStd

#endif
