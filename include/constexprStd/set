/**
 ** This file is part of the constexprStd project.
 ** Copyright 2017 Björn Schäpers <bjoern@hazardy.de>.
 **
 ** This program is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as
 ** published by the Free Software Foundation, either version 3 of the
 ** License, or (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file
 * @brief Contains the constexpr variants of <set>
 */

#ifndef CONSTEXPRSTD_SET
#define CONSTEXPRSTD_SET

#include <experimental/type_traits>
#include <iterator>
#include <limits>
#include <memory>

#include "algorithm"
#include "details/set.hpp"
#include "iterator"
#include "memory"

namespace constexprStd {
template<typename Key, std::size_t N, typename Compare,
         template<typename, std::size_t> typename Allocator,
         typename NodeType = details::SetNode<Key>, std::size_t AllocN = N>
class set_base {
	public:
	using key_type               = Key;
	using value_type             = Key;
	using iterator               = details::SetNodeIterator<Key>;
	using const_iterator         = details::SetNodeIterator<Key>;
	using size_type              = std::size_t;
	using difference_type        = std::ptrdiff_t;
	using key_compare            = Compare;
	using value_compare          = Compare;
	using allocator_type         = Allocator<NodeType, AllocN>;
	using reference              = value_type&;
	using const_reference        = const value_type&;
	using pointer                = value_type*;
	using const_pointer          = const value_type*;
	using reverse_iterator       = std::reverse_iterator<iterator>;
	using const_reverse_iterator = std::reverse_iterator<const_iterator>;
	
	template<typename K = value_type>
	using CmpIsNoexcept = std::bool_constant<noexcept(std::declval<Compare&>()(std::declval<const K&>(),
	                                                                           std::declval<const value_type&>())) &&
	                                         noexcept(std::declval<Compare&>()(std::declval<const value_type&>(),
	                                                                           std::declval<const K&>()))>;
	using AllocIsNoexcept     = std::bool_constant<noexcept(std::declval<allocator_type&>().allocate(1))>;
	using DestroyIsNoexcept   = std::bool_constant<
		noexcept(std::declval<allocator_type&>().destroy(std::declval<NodeType*>()))>;
	template<typename... Args>
	using CreateIsNoexcept = std::bool_constant<
		noexcept(std::declval<allocator_type&>().construct(std::declval<NodeType*>(), std::declval<details::NodeTag>(),
		                                                   std::declval<Args&&>()...))>;
	template<typename T>
	using InsertIsNoexcept = std::bool_constant<CreateIsNoexcept<T&&>::value>;
	template<typename... Args>
	using EmplaceIsNoexcept = CreateIsNoexcept<Args&&...>;
	
	template<typename T>
	using HasIsTransparent = typename T::is_transparent;
	template<typename K>
	using CmpIsTransparent = std::experimental::is_detected<HasIsTransparent, Compare>;
	
	private:
	allocator_type& Alloc;
	NodeType End{};
	NodeType *Root = &End;
	size_type Nodes = 0;
	value_compare Cmp;
	
	template<typename K>
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNode(const K& key, NodeType *hintNode) const
			noexcept(CmpIsNoexcept<K>::value) {
		if ( hintNode != Root ) {
			if ( Cmp(key, hintNode->getContent()) ) {
				if ( auto prev = hintNode->prev(); prev && Cmp(key, prev->getContent()) ) {
					hintNode = Root;
				} //if ( auto prev = hintNode->prev(); prev && Cmp(key, prev->getContent()) )
			} //if ( Cmp(key, hintNode->getContent()) )
			else {
				if ( auto next = hintNode->next(); next && !next->PastEnd && !Cmp(key, next->getContent()) ) {
					hintNode = Root;
				} //if ( auto next = hintNode->next(); next && !next->PastEnd && !Cmp(key, next->getContent()) )
			} //else -> if ( Cmp(key, hintNode->getContent()) )
		} //if ( hintNode != Root )
		return findBestNode(hintNode, key);
	}
	
	template<typename K>
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNode(NodeType *node, const K& key) const
			noexcept(CmpIsNoexcept<K>::value) {
		if ( Cmp(key, node->getContent()) ) {
			return findBestNodeLeft(node, key);
		} //if ( Cmp(key, node->getContent()) )
		if ( Cmp(node->getContent(), key) ) {
			return findBestNodeRight(node, key);
		} //if ( Cmp(node->getContent(), key) )
		//The key is equal to the key of node
		return {node, true};
	}
	
	template<typename K>
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNodeLeft(NodeType *node, const K& key)
			const noexcept(CmpIsNoexcept<K>::value) {
		if ( !node->hasLeftChild() ) {
			return {node, false};
		} //if ( !node->hasLeftChild() )
		return findBestNode(node->LeftChild, key);
	}
	
	template<typename K>
	[[nodiscard]] constexpr std::pair<NodeType*, bool> findBestNodeRight(NodeType *node, const K& key)
			const noexcept(CmpIsNoexcept<K>::value) {
		if ( !node->hasRightChild() || node->RightChild == &End ) {
			return {node, false};
		} //if ( !node->hasRightChild() || node->RightChild == &End )
		return findBestNode(node->RightChild, key);
	}
	
	template<typename... Args>
	[[nodiscard]] constexpr NodeType* createNode(Args&&... args)
			noexcept(AllocIsNoexcept::value && CreateIsNoexcept<Args&&...>::value) {
		NodeType *ret = Alloc.allocate(1);
		Alloc.construct(ret, details::NodeTag{}, std::forward<Args>(args)...);
		return ret;
	}
	
	constexpr void destroyNodeRecursive(NodeType *node) noexcept(DestroyIsNoexcept::value) {
		if ( node == nullptr ) {
			return;
		} //if ( node == nullptr )
		destroyNodeRecursive(node->LeftChild);
		destroyNodeRecursive(node->RightChild);
		destroyNode(node);
		return;
	}
	
	constexpr void destroyNode(NodeType *node) noexcept(DestroyIsNoexcept::value) {
		node->reset();
		Alloc.destroy(node);
		Alloc.deallocate(node, 1);
		return;
	}
	
	template<typename T>
	[[nodiscard]] constexpr std::pair<iterator, bool> insertImpl(const NodeType *hintNode, T&& value)
			noexcept(CmpIsNoexcept<>::value && InsertIsNoexcept<T&&>::value) {
		std::pair<NodeType*, bool> result = findBestNode(value, hintNode == Root ? Root : hintNode->fancyThis());
		NodeType *node = result.first;
		if ( result.second ) {
			return {node, false};
		} //if ( result.second )
		
		auto newNode = createNode(std::forward<T>(value));
		++Nodes;
		if ( Cmp(newNode->getContent(), node->getContent()) ) {
			node->adoptLeft(newNode);
		} //if ( Cmp(newNode->getContent(), node->getContent()) )
		else {
			const bool adaptEnd = node->isRightChild(&End);
			if ( adaptEnd ) {
				End.markForAdoption();
			} //if ( adaptEnd )
			node->adoptRight(newNode);
			if ( adaptEnd ) {
				newNode->adoptRight(&End);
			} //if ( adaptEnd )
		} //else -> if ( Cmp(newNode->getContent(), node->getContent()) )
		rebalanceTreeAfterInsert(newNode);
		return {newNode, true};
	}
	
	template<typename T>
	constexpr void insertRoot(T&& value) noexcept(InsertIsNoexcept<T&&>::value) {
		Root = createNode(std::forward<T>(value));
		Root->adoptRight(&End);
		Root->Color = details::NodeColor::Black;
		Nodes = 1;
		return;
	}
	
	template<typename... Args>
	std::pair<iterator, bool> emplaceImpl(const NodeType *hintNode, Args&&... args)
			noexcept(CmpIsNoexcept<>::value && EmplaceIsNoexcept<Args&&...>::value) {
		auto newNode = createNode(std::forward<Args>(args)...);
		
		if ( empty() ) {
			Root = newNode;
			Root->adoptRight(&End);
			Root->Color = details::NodeColor::Black;
			Nodes = 1;
			return {Root, true};
		} //if ( empty() )
		
		try {
			std::pair<NodeType*, bool> result = findBestNode(newNode->getContent(),
			                                                 hintNode == Root ? Root : hintNode->fancyThis());
			NodeType *node = result.first;
			if ( result.second ) {
				destroyNode(newNode);
				return {node, false};
			} //if ( result.second )
			
			++Nodes;
			if ( Cmp(newNode->getContent(), node->getContent()) ) {
				node->adoptLeft(newNode);
			} //if ( Cmp(newNode->getContent(), node->getContent()) )
			else {
				const bool adaptEnd = node->isRightChild(&End);
				if ( adaptEnd ) {
					End.markForAdoption();
				} //if ( adaptEnd )
				node->adoptRight(newNode);
				if ( adaptEnd ) {
					newNode->adoptRight(&End);
				} //if ( adaptEnd )
			} //else -> if ( Cmp(newNode->getContent(), node->getContent()) )
			rebalanceTreeAfterInsert(newNode);
			return {newNode, true};
		} //try
		catch ( ... ) {
			destroyNode(newNode);
			throw;
		} //catch ( ... )
	}
	
	constexpr NodeType* eraseImpl(NodeType *node) noexcept(DestroyIsNoexcept::value) {
		auto ret = node->next();
		
		//Detach end
		End.markForAdoption();
		
		//Make sure we have at most one child
		if ( node->hasTwoChildren() ) {
			//Since we go into the left subtree we can never end up with the end node
			switchNode(node, node->LeftChild->rightestNode());
		} //if ( node->hasTwoChildren() )
		
		/* If the node is red, we can just replace it with its child, if there is one and mark the child black.
		 * If the node is black and has a child, the child has to be red, otherwise the node must have two children to
		 * have the same black depth in both paths.
		 * The remaining case is, the node is black and has no children. We remove the node, but have to add a black
		 * node along the path to restore the black depth. */
		auto child  = node->onlyChild();
		auto parent = node->Parent;
		auto dir    = node->markForAdoption();
		if ( node->Color == details::NodeColor::Red || child ) {
			if ( child ) {
				child->Color = details::NodeColor::Black;
				child->markForAdoption();
				if ( parent ) {
					parent->adopt(child, dir);
				} //if ( parent )
				else {
					Root = child;
				} //else -> if ( parent )
			} //if ( child )
		} //if ( node->Color == details::NodeColor::Red || child )
		else {
			restoreBlackDepthAfterErase(nullptr, parent, dir);
		} //else -> if ( node->Color == details::NodeColor::Red || child )
		
		//Update Root and End
		if ( --Nodes == 0 ) {
			Root = &End;
			End.markForAdoption();
		} //if ( --Nodes == 0 )
		else {
			while ( Root->hasParent() ) {
				Root = Root->Parent;
			} //while ( Root->hasParent() )
			
			Root->rightestNode()->adoptRight(&End);
		} //else -> if ( --Nodes == 0 )
		
		destroyNode(node);
		return ret;
	}
	
	constexpr void switchNode(NodeType *node1, NodeType *node2) noexcept {
		auto parent1 = node1->Parent;
		auto dir1    = node1->markForAdoption();
		
		auto parent2 = node2->Parent;
		auto dir2    = node2->markForAdoption();
		
		constexprStd::swap(node1->LeftChild,  node2->LeftChild);
		constexprStd::swap(node1->RightChild, node2->RightChild);
		constexprStd::swap(node1->Color,      node2->Color);
		
		auto correctParentState = [](auto parent, auto child) constexpr noexcept {
				if ( child ) {
					child->Parent = parent;
				} //if ( child )
				return;
			};
		correctParentState(node1, node1->LeftChild);
		correctParentState(node1, node1->RightChild);
		correctParentState(node2, node2->LeftChild);
		correctParentState(node2, node2->RightChild);
		
		auto reparent = [this](auto parent, auto dir, auto node) constexpr noexcept {
				switch ( dir ) {
					case details::NodeDirection::Left  : parent->adoptLeft(node);  break;
					case details::NodeDirection::Right : parent->adoptRight(node); break;
					case details::NodeDirection::None  : Root = node;
				} //switch ( dir )
				return;
			};
		reparent(parent1, dir1, node2);
		if ( node1 == parent2 ) {
			//Switching a node with its child
			switch ( dir2 ) {
				case details::NodeDirection::Left  : node2->adoptLeft(node1);  break;
				case details::NodeDirection::Right : node2->adoptRight(node1); break;
				case details::NodeDirection::None  : std::terminate();
			} //switch ( dir2 )
		} //if ( node1 == parent2 )
		else {
			reparent(parent2, dir2, node1);
		} //else -> if ( node1 == parent2 )
		return;
	}
	
	constexpr void restoreBlackDepthAfterErase(NodeType *node, NodeType *parent, details::NodeDirection dir) noexcept {
		//Case 1: No parent, the node was the root
		if ( !parent ) {
			Root = node;
			return;
		} //if ( !parent )
		
		NodeType *sibling = dir == details::NodeDirection::Right ? parent->LeftChild : parent->RightChild;
		
		//Case 2: The sibling is red
		if ( sibling->Color == details::NodeColor::Red ) {
			//Rotate and switch colors between parent and sibling
			parent->Color  = details::NodeColor::Red;
			sibling->Color = details::NodeColor::Black;
			if ( dir == details::NodeDirection::Left ) {
				rotateLeft(parent, sibling);
				//Update sibling
				sibling = parent->RightChild;
			} //if ( dir == details::NodeDirection::Left )
			else {
				rotateRight(parent, sibling);
				sibling = parent->LeftChild;
			} //else -> if ( dir == details::NodeDirection::Left )
		} //if ( sibling->Color == details::NodeColor::Red )
		
		//Case 3: Parent, sibling, and both nephews are black (can not happen after case 2)
		else if ( parent->Color == details::NodeColor::Black && sibling->Color == details::NodeColor::Black &&
		          sibling->bothChildrenBlack() ) {
			//Mark the sibling as red and move the problem one level up
			sibling->Color = details::NodeColor::Red;
			node = parent;
			if ( node->hasParent() ) {
				parent = node->Parent;
				dir    = parent->directionOf(node);
			} //if ( node->hasParent() )
			else {
				parent = nullptr;
				dir    = details::NodeDirection::None;
			} //else -> if ( node->hasParent() )
			restoreBlackDepthAfterErase(node, parent, dir);
			return;
		} //else if ( parent->Color == details::NodeColor::Black && sibling && bothChildrenBlack() )
		
		//Case 4: Parent is red, sibling and nephews are black
		if ( parent->Color == details::NodeColor::Red && sibling->Color == details::NodeColor::Black &&
		     sibling->bothChildrenBlack() ) {
			//Switch colors between sibling and parent
			sibling->Color = details::NodeColor::Red;
			parent->Color  = details::NodeColor::Black;
			//Everything is fine now
			return;
		} //if ( parent->Color == details::NodeColor::Red && sibling && bothChildrenBlack() )
		
		//Now the sibling is black and at least one of its children is red
		//Case 5: The nephew facing away from node is black
		if ( dir == details::NodeDirection::Left ) {
			if ( auto nephew = sibling->RightChild; !nephew || nephew->Color == details::NodeColor::Black ) {
				//Rotate sibling and the other nephew, than change colors
				auto otherNephew = sibling->LeftChild;
				rotateRight(sibling, otherNephew);
				otherNephew->Color = details::NodeColor::Black;
				sibling->Color     = details::NodeColor::Red;
				//Update sibling
				sibling = otherNephew;
			} //if ( auto nephew = sibling->RightChild; !nephew || nephew->Color == details::NodeColor::Black )
		} //if ( dir == details::NodeDirection::Left )
		else {
			if ( auto nephew = sibling->LeftChild; !nephew || nephew->Color == details::NodeColor::Black ) {
				auto otherNephew = sibling->RightChild;
				rotateLeft(sibling, otherNephew);
				otherNephew->Color = details::NodeColor::Black;
				sibling->Color     = details::NodeColor::Red;
				sibling = otherNephew;
			} //if ( auto nephew = sibling->LeftChild; !nephew || nephew->Color == details::NodeColor::Black )
		} //else -> if ( dir == details::NodeDirection::Left )
		
		//Case 6: Now the outer nephew is the red one
		//Rotate sibling and parent, mark parent black as well as the outer nephew, the sibling gets the color of parent
		if ( dir == details::NodeDirection::Left ) {
			rotateLeft(parent, sibling);
			sibling->RightChild->Color = details::NodeColor::Black;
		} //if ( dir == details::NodeDirection::Left )
		else {
			rotateRight(parent, sibling);
			sibling->LeftChild->Color = details::NodeColor::Black;
		} //else -> if ( dir == details::NodeDirection::Left )
		sibling->Color = parent->Color;
		parent->Color  = details::NodeColor::Black;
		return;
	}
	
	constexpr void rotateLeft(NodeType *parent, NodeType *child) noexcept {
		child->markForAdoption();
		
		if ( auto leftGrandchild = child->LeftChild; leftGrandchild ) {
			leftGrandchild->markForAdoption();
			parent->adoptRight(leftGrandchild);
		} //if ( auto leftGrandchild = child->LeftChild; leftGrandchild )
		
		auto grandparent = parent->Parent;
		auto dir = parent->markForAdoption();
		child->adoptLeft(parent);
		if ( grandparent ) {
			grandparent->adopt(child, dir);
		} //if ( grandparent )
		return;
	}
	
	constexpr void rotateRight(NodeType *parent, NodeType *child) noexcept {
		child->markForAdoption();
		
		if ( auto rightGrandchild = child->RightChild; rightGrandchild ) {
			rightGrandchild->markForAdoption();
			parent->adoptLeft(rightGrandchild);
		} //if ( auto rightGrandchild = child->RightChild; rightGrandchild )
		
		auto grandparent = parent->Parent;
		auto dir = parent->markForAdoption();
		child->adoptRight(parent);
		if ( grandparent ) {
			grandparent->adopt(child, dir);
		} //if ( grandparent )
		return;
	}
	
	constexpr void rebalanceTreeAfterInsert(NodeType *node) noexcept {
		//Cases according to german wikipedia
		//Case 1: Node has no parent, it is the root, is has to be black!
		auto parent = node->Parent;
		if ( !parent ) {
			node->Color = details::NodeColor::Black;
			return;
		} //if ( !parent )
		
		//Case 2: Parent is black, everything is fine
		if ( parent->Color == details::NodeColor::Black ) {
			return;
		} //if ( parent->Color == details::NodeColor::Black )
		
		//Now we know the parent is red, so itself has a parent, there exists a grandparent
		auto grandparent = parent->Parent;
		//And possibly an uncle
		auto uncle = grandparent->otherChild(parent);
		if ( uncle == &End ) {
			uncle = nullptr;
		} //if ( uncle == &End )
		
		//Case 3: Parent and uncle are red
		if ( uncle && uncle->Color == details::NodeColor::Red ) {
			//Switch color from parent, uncle, and grandparent and and restart at the grandparent
			parent->Color = uncle->Color = details::NodeColor::Black;
			grandparent->Color = details::NodeColor::Red;
			rebalanceTreeAfterInsert(grandparent);
			return;
		} //if ( uncle && uncle->Color == details::NodeColor::Red )
		
		//Case 4: If there is an uncle he is black, node and parent are black, the grandparent is black
		//Case 4a: The parent is the left child and node is the right child
		if ( parent->isRightChild(node) && grandparent->isLeftChild(parent) ) {
			//Rotate left from parent and node
			rotateLeft(parent, node);
			//Change the names and continue with case 5
			constexprStd::swap(parent, node);
		} //if ( parent->isRightChild(node) && grandparent->isLeftChild(parent) )
		//Case 4b: Change left and right
		else if ( parent->isLeftChild(node) && grandparent->isRightChild(parent) ) {
			rotateRight(parent, node);
			constexprStd::swap(parent, node);
		} //else if ( parent->isLeftChild(node) && grandparent->isRightChild(parent) )
		
		//Case 5: The uncle is still black, as is the grandparent, node and parent are still red
		if ( grandparent->isLeftChild(parent) ) {
			rotateRight(grandparent, parent);
		} //if ( grandparent->isLeftChild(parent) )
		else {
			rotateLeft(grandparent, parent);
		} //else -> if ( grandparent->isLeftChild(parent) )
		//After rotation change colors of parent and grandparent (which is now a son of parent, weird or?)
		parent->Color = details::NodeColor::Black;
		grandparent->Color = details::NodeColor::Red;
		
		if ( grandparent == Root ) {
			//Update the root, if neccessary.
			Root = parent;
		} //if ( grandparent == Root )
		return;
	}
	
	[[nodiscard]] constexpr bool checkBlackDepth(const NodeType *node, int blackToGo) const noexcept {
		if ( !node ) {
			return blackToGo == 0;
		} //if ( !node )
		
		if ( node->Color == details::NodeColor::Black ) {
			if ( --blackToGo == -1 ) {
				return false;
			} //if ( --blackToGo == -1 )
		} //if ( node->Color == details::NodeColor::Black )
		
		return checkBlackDepth(node->LeftChild, blackToGo) && checkBlackDepth(node->RightChild, blackToGo);
	}
	
	[[nodiscard]] constexpr bool checkBinarySearchTree(const NodeType *node) const noexcept {
		auto left  = node->LeftChild;
		auto right = node->RightChild;
		
		if ( right == &End ) {
			right = nullptr;
		} //if ( right == &End )
		
		if ( left ) {
			if ( !Cmp(left->getContent(), node->getContent()) ) {
				return false;
			} //if ( !Cmp(left->getContent(), node->getContent()) )
			if ( !checkBinarySearchTree(left) ) {
				return false;
			} //if ( !checkBinarySearchTree(left) )
		} //if ( left )
		
		if ( right ) {
			if ( !Cmp(node->getContent(), right->getContent()) ) {
				return false;
			} //if ( !Cmp(node->getContent(), right->getContent()) )
			if ( !checkBinarySearchTree(right) ) {
				return false;
			} //if ( !checkBinarySearchTree(right) )
		} //if ( right )
		
		return true;
	}
	
	constexpr void takeTree(set_base&& that) noexcept {
		Nodes = constexprStd::exchange(that.Nodes, 0u);
		Root  = constexprStd::exchange(that.Root,  &that.End);
		auto endParent = that.End.Parent;
		that.End.markForAdoption();
		endParent->adoptRight(&End);
		return;
	}
	
	constexpr void moveElementsFrom(set_base&& that)
			noexcept(noexcept(constexprStd::move(that.begin(), that.end(),
			                                     constexprStd::inserter(std::declval<set_base&>(),
			                                                            std::declval<set_base&>().end())))) {
		constexprStd::move(that.begin(), that.end(), constexprStd::inserter(*this, end()));
		return;
	}
	
	[[nodiscard]] constexpr NodeType* copyNode(const NodeType *node)
			noexcept(CreateIsNoexcept<const value_type&>::value) {
		auto ret = createNode(node->getContent());
		ret->Color = node->Color;
		return ret;
	}
	
	constexpr void copyLeft(NodeType *parent, const NodeType *copyParent)
			noexcept(CreateIsNoexcept<const value_type&>::value) {
		if ( !copyParent->hasLeftChild() ) {
			return;
		} //if ( !copyParent->hasLeftChild() )
		
		auto copyChild = copyParent->LeftChild;
		auto child = copyNode(copyChild);
		parent->adoptLeft(child);
		
		copyLeft (child, copyChild);
		copyRight(child, copyChild);
		return;
	}
	
	constexpr void copyRight(NodeType *parent, const NodeType *copyParent)
			noexcept(CreateIsNoexcept<const value_type&>::value) {
		if ( !copyParent->hasRightChild() ) {
			return;
		} //if ( !copyParent->hasRightChild() )
		
		auto copyChild = copyParent->RightChild;
		if ( copyChild->PastEnd ) {
			parent->adoptRight(&End);
			return;
		} //if ( copyChild->PastEnd )
		
		auto child = copyNode(copyChild);
		parent->adoptRight(child);
		
		copyLeft (child, copyChild);
		copyRight(child, copyChild);
		return;
	}
	
	public:
	constexpr set_base(Compare cmp, allocator_type& alloc) noexcept(std::is_nothrow_move_constructible_v<Compare>) :
			Alloc{alloc}, Cmp{std::move(cmp)} {
		return;
	}
	
	constexpr set_base(const set_base& that)
			noexcept(std::is_nothrow_copy_constructible_v<Compare> &&
			         noexcept(std::declval<set_base&>().insert(that.begin(), that.end()))) :
			set_base{that.Cmp, that.Alloc} {
		copyFrom(that);
		return;
	}
	
	constexpr set_base(set_base&& that)
			noexcept(std::is_nothrow_copy_constructible_v<Compare> &&
	                 noexcept(std::declval<set_base&>().takeTree(std::move(that)))) : set_base{that.Cmp, that.Alloc} {
		takeTree(std::move(that));
		that.clear();
		return;
	}
	
	constexpr set_base& operator=(const set_base& that)
			noexcept(std::is_nothrow_constructible_v<set_base, Compare, allocator_type&> &&
			         noexcept(std::declval<set_base&>().copyFrom(that)) &&
			         noexcept(std::declval<set_base&>().clear()) &&
			         noexcept(std::declval<set_base&>().moveFrom(std::declval<set_base&&>())) &&
			         std::is_nothrow_move_assignable_v<Compare>) {
		set_base copy{that.Cmp, Alloc};
		copy.copyFrom(that);
		clear();
		moveFrom(std::move(copy));
		Cmp = std::move(copy.Cmp);
		copy.clear();
		return *this;
	}
	
	constexpr set_base& operator=(set_base&& that)
			noexcept(noexcept(std::declval<set_base&>().clear()) &&
			         noexcept(std::declval<set_base&>().moveFrom(std::move(that)))) {
		clear();
		moveFrom(std::move(that));
		that.clear();
		return *this;
	}
	
	constexpr set_base& operator=(std::initializer_list<value_type> il)
			noexcept(std::is_nothrow_constructible_v<set_base, Compare&, allocator_type&> &&
			         noexcept(std::declval<set_base&>().insert(il.begin(), il.end())) &&
			         noexcept(std::declval<set_base&>().clear()) &&
			         noexcept(std::declval<set_base&>().moveFrom(std::declval<set_base&&>()))) {
		set_base copy{Cmp, Alloc};
		copy.insert(il.begin(), il.end());
		clear();
		moveFrom(std::move(copy));
		copy.clear();
		return *this;
	}
	
	constexpr void copyFrom(const set_base& that) noexcept(CreateIsNoexcept<const value_type&>::value) {
		if ( that.Root->PastEnd ) {
			return;
		} //if ( that.Root->PastEnd )
		
		Root = copyNode(that.Root);
		copyLeft (Root, that.Root);
		copyRight(Root, that.Root);
		
		Nodes = that.Nodes;
		return;
	}
	
	constexpr void moveFrom(set_base&& that)
			noexcept(noexcept(std::declval<set_base&>().takeTree(std::move(that))) &&
			         noexcept(std::declval<set_base&>().moveElementsFrom(std::move(that)))) {
		if ( Alloc == that.Alloc ) {
			takeTree(std::move(that));
		} //if ( Alloc == that.Alloc )
		else {
			moveElementsFrom(std::move(that));
		} //else -> if ( Alloc == that.Alloc )
		return;
	}
	
	[[nodiscard]] constexpr allocator_type& get_allocator(void) const noexcept {
		return Alloc;
	}
	
	[[nodiscard]] constexpr iterator begin(void) noexcept {
		return Root->leftestNode();
	}
	
	[[nodiscard]] constexpr const_iterator begin(void) const noexcept {
		return Root->leftestNode();
	}
	
	[[nodiscard]] constexpr iterator end(void) noexcept {
		return &End;
	}
	
	[[nodiscard]] constexpr const_iterator end(void) const noexcept {
		return &End;
	}
	
	[[nodiscard]] constexpr const_iterator cbegin(void) const noexcept {
		return Root->leftestNode();
	}
	
	[[nodiscard]] constexpr const_iterator cend(void) const noexcept {
		return &End;
	}
	
	[[nodiscard]] constexpr reverse_iterator rbegin(void) noexcept {
		return std::make_reverse_iterator(end());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator rbegin(void) const noexcept {
		return std::make_reverse_iterator(end());
	}
	
	[[nodiscard]] constexpr reverse_iterator rend(void) noexcept {
		return std::make_reverse_iterator(begin());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator rend(void) const noexcept {
		return std::make_reverse_iterator(begin());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator crbegin(void) const noexcept {
		return std::make_reverse_iterator(end());
	}
	
	[[nodiscard]] constexpr const_reverse_iterator crend(void) const noexcept {
		return std::make_reverse_iterator(begin());
	}
	
	[[nodiscard]] constexpr bool empty(void) const noexcept {
		return Nodes == 0;
	}
	
	[[nodiscard]] constexpr size_type size(void) const noexcept {
		return Nodes;
	}
	
	constexpr void clear(void) noexcept(DestroyIsNoexcept::value) {
		if ( empty() ) {
			return;
		} //if ( empty() )
		End.markForAdoption();
		destroyNodeRecursive(Root);
		Root = &End;
		Nodes = 0;
		return;
	}
	
	[[nodiscard]] constexpr size_type max_size(void) const noexcept {
		return static_cast<size_type>(
			std::numeric_limits<typename std::iterator_traits<iterator>::difference_type>::max());
	}
	
	constexpr std::pair<iterator, bool> insert(const value_type& value)
			noexcept(CmpIsNoexcept<>::value && InsertIsNoexcept<const value_type&>::value) {
		if ( empty() ) {
			insertRoot(value);
			return {Root, true};
		} //if ( empty() )
		
		auto ret = insertImpl(Root, value);
		return ret;
	}
	
	constexpr std::pair<iterator, bool> insert(value_type&& value)
			noexcept(CmpIsNoexcept<>::value && InsertIsNoexcept<value_type&&>::value) {
		if ( empty() ) {
			insertRoot(std::move(value));
			return {Root, true};
		} //if ( empty() )
		
		auto ret = insertImpl(Root, std::move(value));
		return ret;
	}
	
	constexpr iterator insert(const_iterator hint, const value_type& value)
			noexcept(CmpIsNoexcept<>::value && InsertIsNoexcept<const value_type&>::value) {
		if ( empty() ) {
			insertRoot(value);
			return Root;
		} //if ( empty() )
		
		const NodeType *hintNode = hint.Node == &End ? End.Parent : hint.Node;
		auto ret = insertImpl(hintNode, value);
		return ret.first;
	}
	
	constexpr iterator insert(const_iterator hint, value_type&& value)
			noexcept(CmpIsNoexcept<>::value && InsertIsNoexcept<value_type&&>::value) {
		if ( empty() ) {
			insertRoot(std::move(value));
			return Root;
		} //if ( empty() )
		
		const NodeType *hintNode = hint.Node == &End ? End.Parent : hint.Node;
		auto ret = insertImpl(hintNode, std::move(value));
		return ret.first;
	}
	
	template<typename InputIter>
	constexpr void insert(const InputIter first, const InputIter last)
			noexcept(noexcept(constexprStd::copy(first, last,
			                                     constexprStd::inserter(std::declval<set_base&>(),
			                                                            std::declval<set_base&>().end())))) {
		constexprStd::copy(first, last, constexprStd::inserter(*this, end()));
		return;
	}
	
	constexpr void insert(const std::initializer_list<value_type> il)
			noexcept(noexcept(std::declval<set_base&>().insert(il.begin(), il.end()))) {
		insert(il.begin(), il.end());
		return;
	}
	
	template<typename... Args>
	std::pair<iterator, bool> emplace(Args&&... args)
			noexcept(CmpIsNoexcept<>::value && EmplaceIsNoexcept<Args&&...>::value) {
		return emplaceImpl(Root, std::forward<Args>(args)...);
	}
	
	template<typename... Args>
	iterator emplace_hint(const const_iterator hint, Args&&... args)
			noexcept(CmpIsNoexcept<>::value && EmplaceIsNoexcept<Args&&...>::value) {
		const auto temp = emplaceImpl(hint.Node, std::forward<Args>(args)...);
		return temp.first;
	}
	
	//No iterator overload needed, because const_iterator and iterator are the same class
	static_assert(std::is_same_v<iterator, const_iterator>);
	constexpr iterator erase(const_iterator pos)
			noexcept(noexcept(std::declval<set_base&>().eraseImpl(std::declval<NodeType*>()))) {
		NodeType *node = Root;
		if ( pos.Node != Root ) {
			node = pos.Node->fancyThis();
		} //if ( pos.Node != Root )
		return eraseImpl(node);
	}
	
	constexpr iterator erase(const const_iterator first, const const_iterator last)
			noexcept(noexcept(std::declval<set_base&>().eraseImpl(std::declval<NodeType*>()))) {
		NodeType *node = Root;
		if ( first.Node != Root ) {
			node = first.Node->fancyThis();
		} //if ( first.Node != Root )
		while ( node != last.Node ) {
			node = eraseImpl(node);
		} //while ( node != last.Node )
		return last;
	}
	
	constexpr size_type erase(const key_type& key)
			noexcept(CmpIsNoexcept<key_type>::value &&
	                 noexcept(std::declval<set_base&>().eraseImpl(std::declval<NodeType*>()))) {
		const auto ret = findBestNode(key, Root);
		if ( ret.second ) {
			eraseImpl(ret.first);
			return 1;
		} //if ( ret.second )
		return 0;
	}
	
	[[nodiscard]] constexpr size_type count(const Key& key) const noexcept(CmpIsNoexcept<>::value) {
		const auto ret = findBestNode(key, Root);
		return ret.second ? 1 : 0;
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr size_type count(const K& k) const noexcept(CmpIsNoexcept<K>::value) {
		const auto ret = findBestNode(k, Root);
		return ret.second ? 1 : 0;
	}
	
	[[nodiscard]] constexpr iterator find(const Key& key) noexcept(CmpIsNoexcept<>::value) {
		const auto ret = findBestNode(key, Root);
		return ret.second ? ret.first : &End;
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr iterator find(const K& k) noexcept(CmpIsNoexcept<K>::value) {
		const auto ret = findBestNode(k, Root);
		return ret.second ? ret.first : &End;
	}
	
	[[nodiscard]] constexpr const_iterator find(const Key& key) const noexcept(CmpIsNoexcept<>::value) {
		const auto ret = findBestNode(key, Root);
		return ret.second ? ret.first : &End;
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr const_iterator find(const K& k) const noexcept(CmpIsNoexcept<K>::value) {
		const auto ret = findBestNode(k, Root);
		return ret.second ? ret.first : &End;
	}
	
	[[nodiscard]] constexpr iterator lower_bound(const Key& key) noexcept(CmpIsNoexcept<>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(key, Root);
		if ( ret.second || !Cmp(ret.first->getContent(), key) ) {
			return ret.first;
		} //if ( ret.second || !Cmp(ret.first->getContent(), key) )
		return ret.first->next();
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr iterator lower_bound(const K& k) noexcept(CmpIsNoexcept<K>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(k, Root);
		if ( ret.second || !Cmp(ret.first->getContent(), k) ) {
			return ret.first;
		} //if ( ret.second || !Cmp(ret.first->getContent(), k) )
		return ret.first->next();
	}
	
	[[nodiscard]] constexpr const_iterator lower_bound(const Key& key) const noexcept(CmpIsNoexcept<>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(key, Root);
		if ( ret.second || !Cmp(ret.first->getContent(), key) ) {
			return ret.first;
		} //if ( ret.second || !Cmp(ret.first->getContent(), key) )
		return ret.first->next();
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr const_iterator lower_bound(const K& k) const noexcept(CmpIsNoexcept<K>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(k, Root);
		if ( ret.second || !Cmp(ret.first->getContent(), k) ) {
			return ret.first;
		} //if ( ret.second || !Cmp(ret.first->getContent(), k) )
		return ret.first->next();
	}
	
	[[nodiscard]] constexpr iterator upper_bound(const Key& key) noexcept(CmpIsNoexcept<>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(key, Root);
		if ( !ret.second && Cmp(key, ret.first->getContent()) ) {
			return ret.first;
		} //if ( !ret.second && Cmp(key, ret.first->getContent()) )
		return ret.first->next();
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr iterator upper_bound(const K& k) noexcept(CmpIsNoexcept<K>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(k, Root);
		if ( !ret.second && Cmp(k, ret.first->getContent()) ) {
			return ret.first;
		} //if ( !ret.second && Cmp(k, ret.first->getContent()) )
		return ret.first->next();
	}
	
	[[nodiscard]] constexpr const_iterator upper_bound(const Key& key) const noexcept(CmpIsNoexcept<>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(key, Root);
		if ( !ret.second && Cmp(key, ret.first->getContent()) ) {
			return ret.first;
		} //if ( !ret.second && Cmp(key, ret.first->getContent()) )
		return ret.first->next();
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr const_iterator upper_bound(const K& k) const noexcept(CmpIsNoexcept<K>::value) {
		if ( empty() ) {
			return &End;
		} //if ( empty() )
		
		auto ret = findBestNode(k, Root);
		if ( !ret.second && Cmp(k, ret.first->getContent()) ) {
			return ret.first;
		} //if ( !ret.second && Cmp(k, ret.first->getContent()) )
		return ret.first->next();
	}
	
	[[nodiscard]] constexpr std::pair<iterator, iterator> equal_range(const Key& key) noexcept(CmpIsNoexcept<>::value) {
		if ( empty() ) {
			return {&End, &End};
		} //if ( empty() )
		
		auto lb = lower_bound(key);
		if ( lb.Node == &End || Cmp(key, *lb) ) {
			return {lb, lb};
		} //if ( lb.Node == &End || Cmp(key, *lb) )
		return {lb, constexprStd::next(lb)};
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr std::pair<iterator, iterator> equal_range(const K& k) noexcept(CmpIsNoexcept<K>::value) {
		if ( empty() ) {
			return {&End, &End};
		} //if ( empty() )
		
		auto lb = lower_bound(k);
		if ( lb.Node == &End || Cmp(k, *lb) ) {
			return {lb, lb};
		} //if ( lb.Node == &End || Cmp(k, *lb) )
		return {lb, constexprStd::next(lb)};
	}
	
	[[nodiscard]] constexpr std::pair<const_iterator, const_iterator> equal_range(const Key& key) const
			noexcept(CmpIsNoexcept<>::value) {
		if ( empty() ) {
			return {&End, &End};
		} //if ( empty() )
		
		auto lb = lower_bound(key);
		if ( lb.Node == &End || Cmp(key, *lb) ) {
			return {lb, lb};
		} //if ( lb.Node == &End || Cmp(key, *lb) )
		return {lb, constexprStd::next(lb)};
	}
	
	template<typename K, std::enable_if_t<CmpIsTransparent<K>::value>* = nullptr>
	[[nodiscard]] constexpr std::pair<const_iterator, const_iterator> equal_range(const K& k) const
			noexcept(CmpIsNoexcept<K>::value) {
		if ( empty() ) {
			return {&End, &End};
		} //if ( empty() )
		
		auto lb = lower_bound(k);
		if ( lb.Node == &End || Cmp(k, *lb) ) {
			return {lb, lb};
		} //if ( lb.Node == &End || Cmp(k, *lb) )
		return {lb, constexprStd::next(lb)};
	}
	
	[[nodiscard]] constexpr key_compare key_comp(void) const noexcept {
		return Cmp;
	}
	
	[[nodiscard]] constexpr value_compare value_comp(void) const noexcept {
		return Cmp;
	}
	
	[[nodiscard]] constexpr bool checkBlackDepth(void) const noexcept {
		if ( empty() ) {
			return true;
		} //if ( empty() )
		
		if ( Root->Color == details::NodeColor::Red ) {
			return false;
		} //if ( Root->Color == details::NodeColor::Red )
		
		int blackCount = 1;
		for ( NodeType *node = Root->LeftChild; node; node = node->LeftChild ) {
			if ( node->Color == details::NodeColor::Black ) {
				++blackCount;
			} //if ( node->Color == details::NodeColor::Black )
		} //for ( NodeType *node = Root->LeftChild; node; node = node->LeftChild )
		
		return checkBlackDepth(Root, blackCount);
	}
	
	[[nodiscard]] constexpr bool checkBinarySearchTree(void) const noexcept {
		if ( empty() ) {
			return true;
		} //if ( empty() )
		
		return checkBinarySearchTree(Root);
	}
};

template<typename Key, std::size_t N, typename Compare = std::less<Key>,
         template<typename, std::size_t> typename Allocator = constexprStd::allocator>
class set : public set_base<Key, N, Compare, Allocator> {
	private:
	using Base = set_base<Key, N, Compare, Allocator>;
	
	typename Base::allocator_type Alloc;
	
	public:
	explicit constexpr set(Compare cmp = Compare{}) noexcept(std::is_nothrow_move_constructible_v<Compare>) :
			Base{std::move(cmp), Alloc} {
		return;
	}
	
	template<typename InputIter>
	constexpr set(const InputIter first, const InputIter last, Compare cmp = {})
			noexcept(std::is_nothrow_move_constructible_v<Compare> &&
			         noexcept(std::declval<Base&>().insert(first, last))) : set(std::move(cmp)) {
		Base::insert(first, last);
		return;
	}
	
	constexpr set(const set& that)
			noexcept(std::is_nothrow_copy_constructible_v<Compare> && std::is_nothrow_move_constructible_v<Compare> &&
			         noexcept(std::declval<Base&>().copyFrom(that))) : set(that.key_comp()) {
		Base::copyFrom(that);
		return;
	}
	
	constexpr set(set&& that)
			noexcept(std::is_nothrow_copy_constructible_v<Compare> && std::is_nothrow_move_constructible_v<Compare> &&
			         noexcept(std::declval<Base&>().moveFrom(std::move(that)))) : set(that.key_comp()) {
		Base::moveFrom(std::move(that));
		return;
	}
	
	constexpr set(std::initializer_list<typename Base::value_type> il)
			noexcept(std::is_nothrow_move_constructible_v<Compare> && noexcept(std::declval<Base&>().insert(il))) :
			set() {
		Base::insert(il);
		return;
	}
	
	constexpr set& operator=(const set& that) noexcept(noexcept(std::declval<Base&>().operator=(that))) {
		Base::operator=(that);
		return *this;
	}
	
	constexpr set& operator=(set&& that) noexcept(noexcept(std::declval<Base&>().operator=(std::move(that)))) {
		Base::operator=(std::move(that));
		return *this;
	}
};

template<typename Key, std::size_t N, typename Compare = std::less<Key>,
         template<typename, std::size_t> typename Allocator = constexprStd::allocator>
class setDestroy : public set<Key, N, Compare, Allocator> {
	private:
	using Base = set<Key, N, Compare, Allocator>;
	
	public:
	constexpr setDestroy(void) = default;
	
	using Base::Base;
	
	~setDestroy(void) noexcept(noexcept(std::declval<Base&>().clear())) {
		Base::clear();
		return;
	}
};

template<typename Set1, typename Set2,
         std::enable_if_t<std::conjunction_v<details::IsSet<Set1>, details::IsSet<Set2>>>* = nullptr>
constexpr bool operator==(const Set1& set1, const Set2& set2) noexcept(noexcept(constexprStd::equal(set1, set2))) {
	return constexprStd::equal(set1, set2);
}

template<typename Set1, typename Set2,
         std::enable_if_t<std::conjunction_v<details::IsSet<Set1>, details::IsSet<Set2>>>* = nullptr>
constexpr bool operator!=(const Set1& set1, const Set2& set2) noexcept(noexcept(set1 == set2)) {
	return !(set1 == set2);
}

template<typename Set1, typename Set2,
         std::enable_if_t<std::conjunction_v<details::IsSet<Set1>, details::IsSet<Set2>>>* = nullptr>
constexpr bool operator<(const Set1& set1, const Set2& set2)
		noexcept(noexcept(constexprStd::lexicographical_compare(set1, set2))) {
	return constexprStd::lexicographical_compare(set1, set2);
}

template<typename Set1, typename Set2,
         std::enable_if_t<std::conjunction_v<details::IsSet<Set1>, details::IsSet<Set2>>>* = nullptr>
constexpr bool operator>(const Set1& set1, const Set2& set2) noexcept(noexcept(set2 < set1)) {
	return set2 < set1;
}

template<typename Set1, typename Set2,
         std::enable_if_t<std::conjunction_v<details::IsSet<Set1>, details::IsSet<Set2>>>* = nullptr>
constexpr bool operator<=(const Set1& set1, const Set2& set2) noexcept(noexcept(set2 < set1)) {
	return !(set2 < set1);
}

template<typename Set1, typename Set2,
         std::enable_if_t<std::conjunction_v<details::IsSet<Set1>, details::IsSet<Set2>>>* = nullptr>
constexpr bool operator>=(const Set1& set1, const Set2& set2) noexcept(noexcept(set1 < set2)) {
	return !(set1 < set2);
}
} //namespace constexprStd

#endif
