/**
 ** This file is part of the constexprStd project.
 ** Copyright 2017 Björn Schäpers <bjoern@hazardy.de>.
 **
 ** This program is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as
 ** published by the Free Software Foundation, either version 3 of the
 ** License, or (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file
 * @brief Defines constexpr variants of the <algorithm>.
 */

#ifndef CONSTEXPRSTD_ALGORITHM
#define CONSTEXPRSTD_ALGORITHM

#include <iterator>
#include <type_traits>

#include <constexprStd/functional>
#include <constexprStd/iterator>

#include "details/algorithm.hpp"

namespace constexprStd {
/*****                                     Non-modifying sequence operations                                      *****/
template<typename InputIter, typename UnaryPredicate>
constexpr auto count_if(InputIter first, const InputIter last, const UnaryPredicate pred)
		noexcept(std::is_nothrow_constructible_v<typename std::iterator_traits<InputIter>::difference_type,
                                                 decltype(0)> &&
		         noexcept(first != last) && noexcept(++first) && noexcept(pred(*first)) &&
		         noexcept(++std::declval<typename std::iterator_traits<InputIter>::difference_type&>())) {
	typename std::iterator_traits<InputIter>::difference_type ret = 0;
	for ( ; first != last; ++first ) {
		if ( pred(*first) ) {
			++ret;
		} //if ( pred(*first) )
	} //for ( ; first != last; ++first )
	return ret;
}

template<typename Container, typename UnaryPredicate>
constexpr auto count_if(const Container& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::count_if(std::begin(c), std::end(c), pred))) {
	return constexprStd::count_if(std::begin(c), std::end(c), pred);
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(IterT1 first1, const IterT1 last1, IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2) && noexcept(pred(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			return false;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1; ++first1, ++first2 )
	return true;
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2,
		                                      *details::cmp::equal<std::decay_t<decltype(*first1)>,
		                                                           std::decay_t<decltype(*first2)>>))) {
	return constexprStd::equal(first1, last1, first2, *details::cmp::equal<std::decay_t<decltype(*first1)>,
	                                                                       std::decay_t<decltype(*first2)>>);
}

template<typename Container, typename IterT2, typename BinaryPredicate>
constexpr bool equal(const Container& c, const IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(c), std::end(c), first2, pred))) {
	return constexprStd::equal(std::begin(c), std::end(c), first2, pred);
}

template<typename Container, typename IterT2, std::enable_if_t<details::IsIterV<IterT2>>* = nullptr>
constexpr bool equal(const Container& c, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(std::begin(c), std::end(c), first2))) {
	return constexprStd::equal(std::begin(c), std::end(c), first2);
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2,
                     const BinaryPredicate pred)
		noexcept(noexcept(details::equalImpl(first1, last1, first2, last2, pred))) {
	return details::equalImpl(first1, last1, first2, last2, pred);
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2, last2,
		                                      *details::cmp::equal<std::decay_t<decltype(*first1)>,
		                                                           std::decay_t<decltype(*first2)>>))) {
	return constexprStd::equal(first1, last1, first2, last2,
	                           *details::cmp::equal<std::decay_t<decltype(*first1)>,
	                                                std::decay_t<decltype(*first2)>>);
}

template<typename Container1, typename Container2, typename BinaryPredicate>
constexpr bool equal(const Container1& c1, const Container2& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(c1), std::end(c1), std::begin(c2), std::end(c2), pred))) {
	return constexprStd::equal(std::begin(c1), std::end(c1), std::begin(c2), std::end(c2), pred);
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool equal(const Container1& c1, const Container2& c2)
		noexcept(noexcept(constexprStd::equal(std::begin(c1), std::end(c1), std::begin(c2), std::end(c2)))) {
	return constexprStd::equal(std::begin(c1), std::end(c1), std::begin(c2), std::end(c2));
}

template<typename InputIter, typename UnaryPredicate>
constexpr InputIter find_if(InputIter first, const InputIter last, const UnaryPredicate pred)
		noexcept(noexcept(first != last && !pred(*first)) && noexcept(++first)) {
	for ( ; first != last && !pred(*first); ++first ) {
		
	} //for ( ; first != last && !pred(*first); ++first )
	return first;
}

template<typename Container, typename UnaryPredicate>
constexpr auto find_if(const Container& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(std::begin(c), std::end(c), pred))) {
	return constexprStd::find_if(std::begin(c), std::end(c), pred);
}

template<typename InputIter, typename T>
constexpr InputIter find(const InputIter first, const InputIter last, const T& t)
		noexcept(noexcept(constexprStd::find_if(first, last, details::cmp::Equal{t}))) {
	return constexprStd::find_if(first, last, details::cmp::Equal{t});
}

template<typename Container, typename T>
constexpr auto find(const Container& c, const T& t)
		noexcept(noexcept(constexprStd::find(std::begin(c), std::end(c), t))) {
	return constexprStd::find(std::begin(c), std::end(c), t);
}

template<typename InputIter, typename UnaryPredicate>
constexpr InputIter find_if_not(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, constexprStd::not_fn(std::move(pred))))) {
	return constexprStd::find_if(first, last, constexprStd::not_fn(std::move(pred)));
}

template<typename Container, typename UnaryPredicate>
constexpr auto find_if_not(const Container& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if_not(std::begin(c), std::end(c), pred))) {
	return constexprStd::find_if_not(std::begin(c), std::end(c), pred);
}

/*****                                       Modifying sequence operations                                        *****/

template<typename InputIterator, typename OutputIterator>
constexpr OutputIterator copy(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(*destination = *sourceFirst)) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination ) {
		*destination = *sourceFirst;
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination )
	return destination;
}

template<typename Container, typename OutputIterator>
constexpr OutputIterator copy(const Container& container, OutputIterator destination)
		noexcept(noexcept(copy(std::begin(container), std::end(container), destination))) {
	return copy(std::begin(container), std::end(container), destination);
}

} //namespace constexprStd

#endif
