/**
 ** This file is part of the constexprStd project.
 ** Copyright 2017 Björn Schäpers <bjoern@hazardy.de>.
 **
 ** This program is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as
 ** published by the Free Software Foundation, either version 3 of the
 ** License, or (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file
 * @brief Defines constexpr variants of the <algorithm>.
 */

#ifndef CONSTEXPRSTD_ALGORITHM
#define CONSTEXPRSTD_ALGORITHM

#include <iterator>
#include <type_traits>

#include "details/algorithm.hpp"
#include "functional"
#include "iterator"

namespace constexprStd {
/*****                                     Non-modifying sequence operations                                      *****/
template<typename InputIter, typename UnaryFunction>
constexpr UnaryFunction for_each(InputIter first, const InputIter last, UnaryFunction f)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(f(*first))) {
	for ( ; first != last; ++first ) {
		f(*first);
	} //for ( ; first != last; ++first )
	return std::move(f);
}

template<typename Container, typename UnaryFunction>
constexpr UnaryFunction for_each(Container&& c, UnaryFunction f)
		noexcept(noexcept(constexprStd::for_each(std::forward<Container>(c).begin(), std::forward<Container>(c).end(),
		                                         std::move(f)))) {
	return std::move(constexprStd::for_each(std::forward<Container>(c).begin(), std::forward<Container>(c).end(),
	                                        std::move(f)));
}

template<typename InputIter, typename Size, typename UnaryFunction>
constexpr InputIter for_each_n(InputIter first, const Size n, UnaryFunction f)
		noexcept(std::is_nothrow_constructible_v<Size, int> && noexcept(std::declval<Size&>() < n) &&
		         noexcept(++std::declval<Size&>(), ++first) && noexcept(f(*first))) {
	for ( Size i = 0; i < n; ++i, ++first ) {
		f(*first);
	} //for ( Size i = 0; i < n; ++i, ++first )
	return first;
}

template<typename InputIter, typename UnaryPredicate>
constexpr auto count_if(InputIter first, const InputIter last, const UnaryPredicate pred)
		noexcept(std::is_nothrow_constructible_v<typename std::iterator_traits<InputIter>::difference_type,
		                                         decltype(0)> &&
		         noexcept(first != last) && noexcept(++first) && noexcept(pred(*first)) &&
		         noexcept(++std::declval<typename std::iterator_traits<InputIter>::difference_type&>())) {
	typename std::iterator_traits<InputIter>::difference_type ret = 0;
	for ( ; first != last; ++first ) {
		if ( pred(*first) ) {
			++ret;
		} //if ( pred(*first) )
	} //for ( ; first != last; ++first )
	return ret;
}

template<typename Container, typename UnaryPredicate>
constexpr auto count_if(Container&& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::count_if(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), pred))) {
	return constexprStd::count_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), pred);
}

template<typename InputIter, typename T>
constexpr auto count(const InputIter first, const InputIter last, const T& t)
		noexcept(noexcept(constexprStd::count_if(first, last, details::cmp::EqualToValue{t}))) {
	return constexprStd::count_if(first, last, details::cmp::EqualToValue{t});
}

template<typename Container, typename T>
constexpr auto count(Container&& c, const T& t)
		noexcept(noexcept(constexprStd::count(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), t))) {
	return constexprStd::count(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), t);
}

template<typename InputIter1, typename InputIter2, typename BinaryPredicate>
constexpr std::pair<InputIter1, InputIter2> mismatch(InputIter1 first1, const InputIter1 last1, InputIter2 first2,
                                                     const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2) && noexcept(!pred(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			break;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1; ++first1, ++first2 )
	return {first1, first2};
}

template<typename InputIter1, typename InputIter2>
constexpr std::pair<InputIter1, InputIter2> mismatch(const InputIter1 first1, const InputIter1 last1,
                                                     const InputIter2 first2)
		noexcept(noexcept(constexprStd::mismatch(first1, last1, first2, details::cmp::Equal{}))) {
	return constexprStd::mismatch(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename InputIter2, typename BinaryPredicate>
constexpr std::pair<decltype(std::begin(std::declval<Container&&>())), InputIter2>
		mismatch(Container&& c, const InputIter2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::mismatch(std::begin(std::forward<Container>(c)),
	                              std::end(std::forward<Container>(c)), first2, pred);
}

template<typename Container, typename InputIter2, std::enable_if_t<details::IsIterV<InputIter2>>* = nullptr>
constexpr std::pair<decltype(std::begin(std::declval<Container&&>())), InputIter2>
		mismatch(Container&& c, const InputIter2 first2)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::mismatch(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), first2);
}

template<typename InputIter1, typename InputIter2, typename BinaryPredicate>
constexpr std::pair<InputIter1, InputIter2> mismatch(InputIter1 first1, const InputIter1 last1,
                                                     InputIter2 first2, const InputIter2 last2,
                                                     const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1 && first2 != last2) && noexcept(++first1, ++first2) &&
		         noexcept(!pred(*first1, *first2))) {
	for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			break;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 )
	return {first1, first2};
}

template<typename InputIter1, typename InputIter2>
constexpr std::pair<InputIter1, InputIter2> mismatch(const InputIter1 first1, const InputIter1 last1,
                                                     const InputIter2 first2, const InputIter2 last2)
		noexcept(noexcept(constexprStd::mismatch(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::mismatch(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2, typename BinaryPredicate>
constexpr auto mismatch(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container1>(c1)),
		                                         std::end(std::forward<Container1>(c1)),
		                                         std::begin(std::forward<Container2>(c2)),
		                                         std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::mismatch(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                              std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)),
	                              pred);
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr auto mismatch(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container1>(c1)),
		                                         std::end(std::forward<Container1>(c1)),
		                                         std::begin(std::forward<Container2>(c2)),
		                                         std::end(std::forward<Container2>(c2))))) {
	return constexprStd::mismatch(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                              std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)));
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(IterT1 first1, const IterT1 last1, IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2) && noexcept(pred(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			return false;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1; ++first1, ++first2 )
	return true;
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2, details::cmp::Equal{}))) {
	return constexprStd::equal(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename IterT2, typename BinaryPredicate>
constexpr bool equal(Container&& c, const IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::equal(std::begin(std::forward<Container>(c)),
	                           std::end(std::forward<Container>(c)), first2, pred);
}

template<typename Container, typename IterT2, std::enable_if_t<details::IsIterV<IterT2>>* = nullptr>
constexpr bool equal(Container&& c, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::equal(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), first2);
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2,
                     const BinaryPredicate pred)
		noexcept(noexcept(details::equalImpl(first1, last1, first2, last2, pred))) {
	return details::equalImpl(first1, last1, first2, last2, pred);
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::equal(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2, typename BinaryPredicate>
constexpr bool equal(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container1>(c1)),
		                                      std::end(std::forward<Container1>(c1)),
		                                      std::begin(std::forward<Container2>(c2)),
		                                      std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::equal(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                           std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)), pred);
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool equal(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container1>(c1)),
		                                      std::end(std::forward<Container1>(c1)),
		                                      std::begin(std::forward<Container2>(c2)),
		                                      std::end(std::forward<Container2>(c2))))) {
	return constexprStd::equal(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                           std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)));
}

template<typename InputIter, typename UnaryPredicate>
constexpr InputIter find_if(InputIter first, const InputIter last, const UnaryPredicate pred)
		noexcept(noexcept(first != last && !pred(*first)) && noexcept(++first)) {
	for ( ; first != last && !pred(*first); ++first ) {
		
	} //for ( ; first != last && !pred(*first); ++first )
	return first;
}

template<typename Container, typename UnaryPredicate>
constexpr auto find_if(Container&& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), pred))) {
	return constexprStd::find_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), pred);
}

template<typename InputIter, typename T>
constexpr InputIter find(const InputIter first, const InputIter last, const T& t)
		noexcept(noexcept(constexprStd::find_if(first, last, details::cmp::EqualToValue{t}))) {
	return constexprStd::find_if(first, last, details::cmp::EqualToValue{t});
}

template<typename Container, typename T>
constexpr auto find(Container&& c, const T& t)
		noexcept(noexcept(constexprStd::find(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), t))) {
	return constexprStd::find(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), t);
}

template<typename InputIter, typename UnaryPredicate>
constexpr InputIter find_if_not(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, constexprStd::not_fn(std::move(pred))))) {
	return constexprStd::find_if(first, last, constexprStd::not_fn(std::move(pred)));
}

template<typename Container, typename UnaryPredicate>
constexpr auto find_if_not(Container&& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if_not(std::begin(std::forward<Container>(c)),
		                                            std::end(std::forward<Container>(c)), pred))) {
	return constexprStd::find_if_not(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                 pred);
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool all_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if_not(first, last, std::move(pred)) == last)) {
	return constexprStd::find_if_not(first, last, std::move(pred)) == last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool all_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::all_of(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::all_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::move(pred));
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool any_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, std::move(pred)) != last)) {
	return constexprStd::find_if(first, last, std::move(pred)) != last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool any_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::any_of(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::any_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::move(pred));
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool none_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, std::move(pred)) == last)) {
	return constexprStd::find_if(first, last, std::move(pred)) == last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool none_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::none_of(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::none_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                             std::move(pred));
}

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr ForwardIter1 find_end(const ForwardIter1 first, const ForwardIter1 last,
                                const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, std::move(pred)))) {
	return details::findEndImpl(first, last, s_first, s_last, std::move(pred));
}

template<typename Container, typename ForwardIter2, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto find_end(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         s_first, s_last, std::move(pred)))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              s_first, s_last, std::move(pred));
}

template<typename Container, typename SearchContainer, typename BinaryPredicate>
constexpr auto find_end(Container&& c, SearchContainer&& s, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         std::begin(std::forward<SearchContainer>(s)),
		                                         std::end(std::forward<SearchContainer>(s)), std::move(pred)))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::begin(std::forward<SearchContainer>(s)),
	                              std::end(std::forward<SearchContainer>(s)), std::move(pred));
}

template<typename ForwardIter1, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter1>>* = nullptr>
constexpr ForwardIter1 find_end(const ForwardIter1 first, const ForwardIter1 last,
                                const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_end(first, last, s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter2>
constexpr auto find_end(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename SearchContainer>
constexpr auto find_end(Container&& c, SearchContainer&& s)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         std::begin(std::forward<SearchContainer>(s)),
		                                         std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{}))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::begin(std::forward<SearchContainer>(s)),
	                              std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{});
}

template<typename InputIter, typename ForwardIter, typename BinaryPredicate>
constexpr InputIter find_first_of(InputIter first, const InputIter last,
                                  const ForwardIter s_first, const ForwardIter s_last, BinaryPredicate pred)
		noexcept(noexcept(s_first == s_last) && noexcept(first != last) && noexcept(++first) &&
		         std::is_nothrow_copy_constructible_v<ForwardIter> && noexcept(s_first != s_last) &&
		         noexcept(++std::declval<ForwardIter&>()) && noexcept(pred(*first, *s_first))) {
	if ( s_first == s_last ) {
		return last;
	} //if ( s_first == s_last )
	
	for ( ; first != last; ++first ) {
		for ( auto scan = s_first; scan != s_last; ++scan ) {
			if ( pred(*first, *scan) ) {
				return first;
			} //if ( pred(*first, *scan) )
		} //for ( auto scan = s_first; scan != s_last; ++scan )
	} //for ( ; first != last; ++first )
	return last;
}

template<typename Container, typename ForwardIter, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto find_first_of(Container&& c, const ForwardIter s_first, const ForwardIter s_last, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)),
		                                              s_first, s_last, std::move(pred)))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   s_first, s_last, std::move(pred));
}

template<typename Container, typename SearchContainer, typename BinaryPredicate>
constexpr auto find_first_of(Container&& c, SearchContainer&& s, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)),
		                                              std::begin(std::forward<SearchContainer>(s)),
		                                              std::end(std::forward<SearchContainer>(s)), std::move(pred)))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   std::begin(std::forward<SearchContainer>(s)),
	                                   std::end(std::forward<SearchContainer>(s)), std::move(pred));
}

template<typename InputIter, typename ForwardIter, std::enable_if_t<details::IsIterV<InputIter>>* = nullptr>
constexpr InputIter find_first_of(const InputIter first, const InputIter last,
                                  const ForwardIter s_first, const ForwardIter s_last)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_first_of(first, last, s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter>
constexpr auto find_first_of(Container&& c, const ForwardIter s_first, const ForwardIter s_last)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)),
		                                              s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename SearchContainer>
constexpr auto find_first_of(Container&& c, SearchContainer&& s)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         std::begin(std::forward<SearchContainer>(s)),
		                                         std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{}))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::begin(std::forward<SearchContainer>(s)),
	                              std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{});
}

template<typename ForwardIter, typename BinaryPredicate>
constexpr ForwardIter adjacent_find(ForwardIter first, const ForwardIter last, BinaryPredicate pred)
		noexcept(noexcept(first == last) && noexcept(constexprStd::next(first)) && noexcept(first != last) &&
		         noexcept(++first, ++first) && noexcept(pred(*first, *first))) {
	if ( first == last ) {
		return last;
	} //if ( first == last )
	
	for ( auto scan = constexprStd::next(first); scan != last; ++scan, ++first ) {
		if ( pred(*first, *scan) ) {
			return first;
		} //if ( pred(*first, *scan) )
	} //for ( auto scan = constexprStd::next(first); scan != last; ++scan, ++first )
	return last;
}

template<typename Container, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto adjacent_find(Container&& c, BinaryPredicate pred)
			noexcept(noexcept(constexprStd::adjacent_find(std::begin(std::forward<Container>(c)),
			                                              std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::adjacent_find(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   std::move(pred));
}

template<typename ForwardIter, std::enable_if_t<details::IsIterV<ForwardIter>>* = nullptr>
constexpr ForwardIter adjacent_find(const ForwardIter first, const ForwardIter last)
		noexcept(noexcept(constexprStd::adjacent_find(first, last, details::cmp::Equal{}))) {
	return constexprStd::adjacent_find(first, last, details::cmp::Equal{});
}

template<typename Container>
constexpr auto adjacent_find(Container&& c)
		noexcept(noexcept(constexprStd::adjacent_find(std::forward<Container>(c), details::cmp::Equal{}))) {
	return constexprStd::adjacent_find(std::forward<Container>(c), details::cmp::Equal{});
}

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr ForwardIter1 search(ForwardIter1 first, const ForwardIter1 last,
                              const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(first != last) && noexcept(++first) && std::is_nothrow_copy_constructible_v<ForwardIter1> &&
		         std::is_nothrow_copy_constructible_v<ForwardIter2> &&
		         noexcept(first != last && std::declval<ForwardIter2&>() != s_last &&
		                  pred(*first, *std::declval<ForwardIter2&>())) &&
		         noexcept(++first, ++std::declval<ForwardIter2&>()) &&
		         noexcept(std::declval<ForwardIter2&>() == s_last) && noexcept(first == last)) {
	for ( ; first != last; ++first ) {
		auto scan = first;
		auto cmp  = s_first;
		for ( ; scan != last && cmp != s_last && pred(*scan, *cmp); ++scan, ++cmp ) {
			
		} //for ( ; scan != last && cmp != s_last && pred(*scan, *cmp); ++scan, ++cmp )
		
		if ( cmp == s_last ) {
			return first;
		} //if ( cmp == s_last )
		
		if ( scan == last ) {
			return last;
		} //if ( scan == last )
	} //for ( ; first != last; ++first )
	return last;
}

template<typename Container, typename ForwardIter2, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto search(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       s_first, s_last, std::move(pred)))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            s_first, s_last, std::move(pred));
}

template<typename Container, typename SearchContainer, typename BinaryPredicate>
constexpr auto search(Container&& c, SearchContainer&& s, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       std::begin(std::forward<SearchContainer>(s)),
		                                       std::end(std::forward<SearchContainer>(s)), std::move(pred)))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::begin(std::forward<SearchContainer>(s)),
	                            std::end(std::forward<SearchContainer>(s)), std::move(pred));
}

template<typename ForwardIter1, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter1>>* = nullptr>
constexpr ForwardIter1 search(const ForwardIter1 first, const ForwardIter1 last,
                              const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::search(first, last, s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter2>
constexpr auto search(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename SearchContainer,
         std::enable_if_t<std::negation_v<details::IsSearcher<SearchContainer,
                                                              decltype(std::begin(std::declval<Container&&>()))>>>* =
         nullptr>
constexpr auto search(Container&& c, SearchContainer&& s)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       std::begin(std::forward<SearchContainer>(s)),
		                                       std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{}))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::begin(std::forward<SearchContainer>(s)),
	                            std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{});
}

template<typename ForwardIter, typename Searcher>
constexpr ForwardIter search(const ForwardIter first, const ForwardIter last, const Searcher& searcher)
		noexcept(noexcept(searcher(first, last).first)) {
	return searcher(first, last).first;
}

template<typename Container, typename Searcher,
         std::enable_if_t<details::IsSearcherV<Searcher, decltype(std::begin(std::declval<Container&&>()))>>* = nullptr>
constexpr auto search(Container&& c, const Searcher& searcher)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), searcher))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), searcher);
}

template<typename ForwardIter, typename Count, typename T, typename BinaryPredicate = std::equal_to<>>
constexpr ForwardIter search_n(ForwardIter first, const ForwardIter last, const Count count, const T& value,
                               BinaryPredicate pred = {})
		noexcept(noexcept(first != last) && std::is_nothrow_copy_constructible_v<ForwardIter> &&
		         std::is_nothrow_constructible_v<Count, int> &&
		         noexcept(std::declval<Count&>() < count && first != last) &&
		         noexcept(++std::declval<Count&>(), ++first) && noexcept(!pred(*first, value)) &&
		         noexcept(std::declval<Count&>() == count) && noexcept(++first) &&
		         std::is_nothrow_copy_assignable_v<ForwardIter>) {
	while ( first != last ) {
		auto scan = first;
		Count i = 0;
		for ( ; i < count && scan != last; ++i, ++scan ) {
			if ( !pred(*scan, value) ) {
				break;
			} //if ( !pred(*scan, value) )
		} //for ( ; i < count && scan != last; ++i, ++scan )
		
		if ( i == count ) {
			return first;
		} //if ( i == count )
		
		if ( scan == last ) {
			return last;
		} //if ( scan == last )
		
		first = ++scan;
	} //while ( first != last )
	return last;
}

template<typename Container, typename Count, typename T, typename BinaryPredicate = std::equal_to<>>
constexpr auto search_n(Container&& c, const Count count, const T& value, BinaryPredicate pred = {})
		noexcept(noexcept(constexprStd::search_n(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), count, value, std::move(pred)))) {
	return constexprStd::search_n(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), count,
	                              value, std::move(pred));
}

/*****                                       Modifying sequence operations                                        *****/

template<typename InputIterator, typename OutputIterator>
constexpr OutputIterator copy(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(*destination = *sourceFirst)) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination ) {
		*destination = *sourceFirst;
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination )
	return destination;
}

template<typename Container, typename OutputIterator>
constexpr OutputIterator copy(Container&& c, const OutputIterator destination)
		noexcept(noexcept(constexprStd::copy(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), destination))) {
	return constexprStd::copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                          destination);
}

template<typename InputIterator, typename OutputIterator, typename UnaryPredicate>
constexpr OutputIterator copy_if(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination,
                                 UnaryPredicate pred)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(pred(*sourceFirst)) && noexcept(*destination = *sourceFirst)) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst ) {
		if ( pred(*sourceFirst) ) {
			*destination = *sourceFirst;
			++destination;
		} //if ( pred(*sourceFirst) )
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst )
	return destination;
}

template<typename Container, typename OutputIterator, typename UnaryPredicate>
constexpr OutputIterator copy_if(Container&& c, const OutputIterator destination, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::copy_if(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), destination, std::move(pred)))) {
	return constexprStd::copy_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                             destination, std::move(pred));
}

template<typename InputIter, typename Size, typename OutputIter>
constexpr OutputIter copy_n(InputIter first, Size count, OutputIter result)
		noexcept(noexcept(count-- > 0) && noexcept(*result = *first) && noexcept(++result) && noexcept(++first)) {
	while ( count-- > 0 ) {
		*result = *first;
		++result;
		++first;
	} //while ( count-- > 0 )
	return result;
}

template<typename BidirIter1, typename BidirIter2>
constexpr BidirIter2 copy_backward(const BidirIter1 first, BidirIter1 last, BidirIter2 d_last)
		noexcept(noexcept(first != last) && noexcept(*--d_last = *--last)) {
	while ( first != last ) {
		*--d_last = *--last;
	} //while ( first != last )
	return d_last;
}

template<typename Container, typename BidirIter2>
constexpr BidirIter2 copy_backward(Container&& c, const BidirIter2 d_last)
		noexcept(noexcept(constexprStd::copy_backward(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)), d_last))) {
	return constexprStd::copy_backward(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   d_last);
}

template<typename InputIterator, typename OutputIterator>
constexpr OutputIterator move(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(*destination = std::move(*sourceFirst))) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination ) {
		*destination = std::move(*sourceFirst);
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination )
	return destination;
}

template<typename Container, typename OutputIterator>
constexpr OutputIterator move(Container&& c, const OutputIterator destination)
		noexcept(noexcept(constexprStd::move(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), destination))) {
	return constexprStd::move(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                          destination);
}

template<typename BidirIter1, typename BidirIter2>
constexpr BidirIter2 move_backward(const BidirIter1 first, BidirIter1 last, BidirIter2 d_last)
		noexcept(noexcept(first != last) && noexcept(*--d_last = std::move(*--last))) {
	while ( first != last ) {
		*--d_last = std::move(*--last);
	} //while ( first != last )
	return d_last;
}

template<typename Container, typename BidirIter2>
constexpr BidirIter2 move_backward(Container&& c, const BidirIter2 d_last)
		noexcept(noexcept(constexprStd::move_backward(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)), d_last))) {
	return constexprStd::move_backward(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   d_last);
}

template<typename ForwardIter, typename T>
constexpr void fill(ForwardIter first, const ForwardIter last, const T& value)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(*first = value)) {
	for ( ; first != last; ++first ) {
		*first = value;
	} //for ( ; first != last; ++first )
	return;
}

template<typename Container, typename T>
constexpr void fill(Container&& c, const T& value)
		noexcept(noexcept(constexprStd::fill(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), value))) {
	constexprStd::fill(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), value);
	return;
}

template<typename OutputIter, typename Size, typename T>
constexpr OutputIter fill_n(OutputIter first, Size count, const T& value)
		noexcept(noexcept(count-- > 0) && noexcept(*first = value) && noexcept(++first)) {
	while ( count-- > 0 ) {
		*first = value;
		++first;
	} //while ( count-- > 0 )
	return first;
}

template<typename ForwardIter, typename OutputIter, typename UnaryOperation>
constexpr OutputIter transform(ForwardIter first, const ForwardIter last, OutputIter d_first, UnaryOperation unary_op)
		noexcept(noexcept(first != last) && noexcept(++first, ++d_first) && noexcept(*d_first = unary_op(*first))) {
	for ( ; first != last; ++first, ++d_first ) {
		*d_first = unary_op(*first);
	} //for ( ; first != last; ++first, ++d_first )
	return d_first;
}

template<typename Container, typename OutputIter, typename UnaryOperation>
constexpr auto transform(Container&& c, const OutputIter d_first, UnaryOperation unary_op)
		noexcept(noexcept(constexprStd::transform(std::begin(std::forward<Container>(c)),
		                                          std::end(std::forward<Container>(c)),
		                                          d_first, std::move(unary_op)))) {
	return constexprStd::transform(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                               d_first, std::move(unary_op));
}

template<typename ForwardIter1, typename ForwardIter2, typename OutputIter, typename BinaryOperation>
constexpr OutputIter transform(ForwardIter1 first1, const ForwardIter1 last1, ForwardIter2 first2, OutputIter d_first,
                               BinaryOperation binary_op)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2, ++d_first) &&
		         noexcept(*d_first = binary_op(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2, ++d_first ) {
		*d_first = binary_op(*first1, *first2);
	} //for ( ; first1 != last1; ++first1, ++first2, ++d_first )
	return d_first;
}

template<typename Container, typename ForwardIter2, typename OutputIter, typename BinaryOperation>
constexpr auto transform(Container&& c, const ForwardIter2 first2, const OutputIter d_first, BinaryOperation binary_op)
		noexcept(noexcept(constexprStd::transform(std::begin(std::forward<Container>(c)),
		                                          std::end(std::forward<Container>(c)),
		                                          first2, d_first, std::move(binary_op)))) {
	return constexprStd::transform(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                               first2, d_first, std::move(binary_op));
}

template<typename ForwardIter, typename Generator>
constexpr void generate(ForwardIter first, const ForwardIter last, Generator gen)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(*first = gen())) {
	for ( ; first != last; ++first ) {
		*first = gen();
	} //for ( ; first != last; ++first )
	return;
}

template<typename Container, typename Generator>
constexpr auto generate(Container&& c, Generator gen)
		noexcept(noexcept(constexprStd::generate(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), std::move(gen)))) {
	return constexprStd::generate(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::move(gen));
}

template<typename OutputIter, typename Size, typename Generator>
constexpr OutputIter generate_n(OutputIter first, Size count, Generator g)
		noexcept(noexcept(count-- > 0) && noexcept(*first = g()) && noexcept(++first)) {
	while ( count-- > 0 ) {
		*first = g();
		++first;
	} //while ( count-- > 0 )
	return first;
}

template<typename ForwardIter, typename UnaryPredicate>
constexpr ForwardIter remove_if(ForwardIter first, const ForwardIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, pred)) && std::is_nothrow_move_assignable_v<ForwardIter> &&
		         noexcept(first == last) && noexcept(constexprStd::next(first)) &&
		         std::is_nothrow_move_constructible_v<ForwardIter> && noexcept(first != last) && noexcept(++first) &&
		         noexcept(!pred(*first)) &&
		         std::is_nothrow_move_assignable_v<typename std::iterator_traits<ForwardIter>::value_type>) {
	first = constexprStd::find_if(first, last, pred);
	if ( first == last ) {
		return first;
	} //if ( first == last )
	
	for ( auto scan = constexprStd::next(first); scan != last; ++scan ) {
		if ( !pred(*scan) ) {
			*first = std::move(*scan);
			++first;
		} //if ( !pred(*scan) )
	} //for ( auto scan = constexprStd::next(first); scan != last; ++scan )
	return first;
}

template<typename Container, typename UnaryPredicate>
constexpr auto remove_if(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::remove_if(std::begin(std::forward<Container>(c)),
		                                          std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::remove_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                               std::move(pred));
}

template<typename ForwardIter, typename T>
constexpr ForwardIter remove(const ForwardIter first, const ForwardIter last, const T& value)
		noexcept(noexcept(constexprStd::remove_if(first, last, details::cmp::EqualToValue{value}))){
	return constexprStd::remove_if(first, last, details::cmp::EqualToValue{value});
}

template<typename Container, typename T>
constexpr auto remove(Container&& c, const T& value)
		noexcept(noexcept(constexprStd::remove(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), value))) {
	return constexprStd::remove(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), value);
}

template<typename InputIter, typename OutputIter, typename UnaryPredicate>
constexpr OutputIter remove_copy_if(const InputIter first, const InputIter last, const OutputIter d_first,
                                    UnaryPredicate pred)
		noexcept(noexcept(constexprStd::copy_if(first, last, d_first, constexprStd::not_fn(std::move(pred))))) {
	return constexprStd::copy_if(first, last, d_first, constexprStd::not_fn(std::move(pred)));
}

template<typename Container, typename OutputIter, typename UnaryPredicate>
constexpr OutputIter remove_copy_if(Container&& c, const OutputIter d_first, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::remove_copy_if(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), d_first,
		                                               std::move(pred)))) {
	return constexprStd::remove_copy_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                    d_first, std::move(pred));
}

template<typename ForwardIter, typename OutputIter, typename T>
constexpr OutputIter remove_copy(const ForwardIter first, const ForwardIter last, const OutputIter d_first,
                                  const T& value)
		noexcept(noexcept(constexprStd::remove_copy_if(first, last, d_first, details::cmp::EqualToValue{value}))){
	return constexprStd::remove_copy_if(first, last, d_first, details::cmp::EqualToValue{value});
}

template<typename Container, typename OutputIter, typename T>
constexpr OutputIter remove_copy(Container&& c, const OutputIter d_first, const T& value)
		noexcept(noexcept(constexprStd::remove_copy(std::begin(std::forward<Container>(c)),
		                                            std::end(std::forward<Container>(c)), d_first, value))) {
	return constexprStd::remove_copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                 d_first, value);
}

template<typename ForwardIter, typename UnaryPredicate, typename T>
constexpr void replace_if(ForwardIter first, const ForwardIter last, UnaryPredicate pred, const T& newValue)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(pred(*first)) &&
		         noexcept(*first = newValue)) {
	for ( ; first != last; ++first ) {
		if ( pred(*first) ) {
			*first = newValue;
		} //if ( pred(*first) )
	} //for ( ; first != last; ++first )
	return;
}

template<typename Container, typename UnaryPredicate, typename T>
constexpr void replace_if(Container&& c, UnaryPredicate pred, const T& newValue)
		noexcept(noexcept(constexprStd::replace_if(std::begin(std::forward<Container>(c)),
		                                           std::end(std::forward<Container>(c)), std::move(pred), newValue))) {
	constexprStd::replace_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                         std::move(pred), newValue);
	return;
}

template<typename ForwardIter, typename T>
constexpr void replace(const ForwardIter first, const ForwardIter last, const T& oldValue, const T& newValue)
		noexcept(noexcept(constexprStd::replace_if(first, last, details::cmp::EqualToValue{oldValue}, newValue))){
	constexprStd::replace_if(first, last, details::cmp::EqualToValue{oldValue}, newValue);
	return;
}

template<typename Container, typename T>
constexpr void replace(Container&& c, const T& oldValue, const T& newValue)
		noexcept(noexcept(constexprStd::replace(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), oldValue, newValue))) {
	constexprStd::replace(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), oldValue,
	                      newValue);
	return;
}

/*****                                        Minimum/Maximum Operations                                          *****/

template<typename InputIter1, typename InputIter2, typename Compare = std::less<>>
constexpr bool lexicographical_compare(InputIter1 first1, const InputIter1 last1,
                                       InputIter2 first2, const InputIter2 last2, Compare comp = Compare{})
noexcept(noexcept(first1 != last1 && first2 != last2) && noexcept(++first1, ++first2) &&
         noexcept(comp(*first1, *first2)) && noexcept(comp(*first2, *first1)) && noexcept(first1 == last1)) {
	for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 ) {
		if ( comp(*first1, *first2) ) {
			return true;
		} //if ( comp(*first1, *first2) )
		if ( comp(*first2, *first1) ) {
			return false;
		} //if ( comp(*first2, *first1) )
	} //for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 )
	return first1 == last1 && (first2 != last2);
}

template<typename Container1, typename Container2, typename Compare = std::less<>>
constexpr bool lexicographical_compare(Container1&& c1, Container2&& c2, Compare comp = Compare{})
		noexcept(noexcept(constexprStd::lexicographical_compare(std::begin(std::forward<Container1>(c1)),
		                                                        std::end(std::forward<Container1>(c1)),
		                                                        std::begin(std::forward<Container2>(c2)),
		                                                        std::end(std::forward<Container2>(c2)),
		                                                        std::move(comp)))) {
	return constexprStd::lexicographical_compare(std::begin(std::forward<Container1>(c1)),
	                                             std::end(std::forward<Container1>(c1)),
	                                             std::begin(std::forward<Container2>(c2)),
	                                             std::end(std::forward<Container2>(c2)), std::move(comp));
}

/*****                                               Permutations                                                 *****/

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr bool is_permutation(ForwardIter1 first1, const ForwardIter1 last1,
                              ForwardIter2 first2, const ForwardIter2 last2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::distance(first1, last1)) && noexcept(constexprStd::distance(first2, last2)) &&
		         noexcept(first1 != last1 && first2 != last2 && pred(*first1, *first2)) &&
		         noexcept(++first1, ++first2) && noexcept(first1 == last1) &&
		         noexcept(std::declval<decltype(constexprStd::distance(first1, last1))>() !=
		                  std::declval<decltype(constexprStd::distance(first2, last2))>()) &&
		         noexcept(std::declval<decltype(constexprStd::distance(first1, last1))>() != 0) &&
		         std::is_nothrow_copy_constructible_v<ForwardIter1> && noexcept(first1 != last1) &&
		         noexcept(++first1) && noexcept(pred(*first1, *first1)) && noexcept(pred(*first2, *first2)) &&
		         noexcept(constexprStd::find_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>())) &&
		         noexcept(constexprStd::count_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>())) &&
		         noexcept(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>())) &&
		         noexcept(std::declval<decltype(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>()))>() == 0) &&
		         noexcept(std::declval<decltype(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>()))>() !=
		                  std::declval<decltype(constexprStd::count_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>()))>())) {
	constexpr bool bothRandomAccess = details::IsRaIter<ForwardIter1>::value && details::IsRaIter<ForwardIter2>::value;
	
	//Compare length for random access, because O(1)
	if constexpr ( bothRandomAccess ) {
		if ( constexprStd::distance(first1, last1) != constexprStd::distance(first2, last2) ) {
			return false;
		} //if ( constexprStd::distance(first1, last1) != constexprStd::distance(first2, last2) )
	} //if constexpr ( bothRandomAccess )
	
	//Search common prefix
	auto mismatchIters = constexprStd::mismatch(first1, last1, first2, last2, pred);
	first1 = mismatchIters.first;
	first2 = mismatchIters.second;
	
	if constexpr ( bothRandomAccess ) {
		if ( first1 == last1 ) {
			//All clear
			return true;
		} //if ( first1 == last1 )
	} //if constexpr ( bothRandomAccess )
	else {
		//Calculate length of remaining ranges
		const auto d1 = constexprStd::distance(first1, last1);
		const auto d2 = constexprStd::distance(first2, last2);
		
		//Can't be a permutation
		if ( d1 != d2 ) {
			return false;
		} //if ( d1 != d2 )
		
		//We have established that d1 == d2, so we only need to check d1
		if ( d1 == 0 ) {
			//Checked complete range, done
			return true;
		} //if ( d1 == 0 )
	} //else -> if constexpr ( bothRandomAccess )
	
	//Now we have to check the real permutation
	for ( auto scan = first1; scan != last1; ++scan ) {
		auto cmpLambda = [&pred,cmp = *scan](const typename std::iterator_traits<ForwardIter2>::value_type& value)
		                 noexcept(noexcept(pred(*scan, value))) {
				return pred(cmp, value);
			};
		
		//Search in [first1,scan) if we already handled this element
		if ( constexprStd::find_if(first1, scan, cmpLambda) != scan ) {
			//We have handled this
			continue;
		} //if ( constexprStd::find_if(first1, scan, cmpLambda) != scan )
		
		const auto matches = constexprStd::count_if(first2, last2, cmpLambda);
		if ( matches == 0 || matches != constexprStd::count_if(scan, last1, cmpLambda) ) {
			return false;
		} //if ( matches == 0 || matches != constexprStd::count_if(scan, last1, cmpLambda) )
	} //for ( auto scan = first1; scan != last1; ++scan )
	return true;
}

template<typename Container1, typename Container2, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool is_permutation(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
		                                               std::end(std::forward<Container1>(c1)),
		                                               std::begin(std::forward<Container2>(c2)),
		                                               std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
	                                    std::end(std::forward<Container1>(c1)),
	                                    std::begin(std::forward<Container2>(c2)),
	                                    std::end(std::forward<Container2>(c2)), pred);
}

template<typename ForwardIter1, typename ForwardIter2>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1,
                              const ForwardIter2 first2, const ForwardIter2 last2)
		noexcept(noexcept(constexprStd::is_permutation(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::is_permutation(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool is_permutation(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
		                                               std::end(std::forward<Container1>(c1)),
		                                               std::begin(std::forward<Container2>(c2)),
		                                               std::end(std::forward<Container2>(c2))))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
	                                    std::end(std::forward<Container1>(c1)),
	                                    std::begin(std::forward<Container2>(c2)),
	                                    std::end(std::forward<Container2>(c2)));
}

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1, const ForwardIter2 first2,
                              const BinaryPredicate pred)
		noexcept(std::is_nothrow_copy_constructible_v<ForwardIter2> &&
		         noexcept(constexprStd::advance(std::declval<ForwardIter2&>(),
		                                        constexprStd::distance(first1, last1))) &&
		         noexcept(constexprStd::is_permutation(first1, last1, first2, std::declval<ForwardIter2&>(), pred))) {
	ForwardIter2 last2 = first2;
	constexprStd::advance(last2, constexprStd::distance(first1, last1));
	return constexprStd::is_permutation(first1, last1, first2, last2, pred);
}

template<typename Container, typename ForwardIter2, typename BinaryPredicate,
         std::enable_if_t<details::IsIterV<ForwardIter2>>* = nullptr>
constexpr bool is_permutation(Container&& c, const ForwardIter2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                    first2, pred);
}

template<typename ForwardIter1, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter1>>* = nullptr>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1, const ForwardIter2 first2)
		noexcept(noexcept(constexprStd::is_permutation(first1, last1, first2, details::cmp::Equal{}))){
	return constexprStd::is_permutation(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter2>>* = nullptr>
constexpr bool is_permutation(Container&& c, const ForwardIter2 first2)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
	                                    std::end(std::forward<Container>(c)), first2);
}
} //namespace constexprStd

#endif
