/**
 ** This file is part of the constexprStd project.
 ** Copyright 2017 Björn Schäpers <bjoern@hazardy.de>.
 **
 ** This program is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as
 ** published by the Free Software Foundation, either version 3 of the
 ** License, or (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file
 * @brief Defines constexpr variants of the <algorithm>.
 */

#ifndef CONSTEXPRSTD_ALGORITHM
#define CONSTEXPRSTD_ALGORITHM

#include <iterator>
#include <type_traits>

#include "details/algorithm.hpp"
#include "details/algorithm_forward.hpp"
#include "details/cmp.hpp"
#include "details/find.hpp"
#include "functional"
#include "iterator"
#include "utility"

namespace constexprStd {
/*****                                     Non-modifying sequence operations                                      *****/
template<typename InputIter, typename UnaryFunction>
constexpr UnaryFunction for_each(InputIter first, const InputIter last, UnaryFunction f)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(f(*first))) {
	for ( ; first != last; ++first ) {
		f(*first);
	} //for ( ; first != last; ++first )
	return std::move(f);
}

template<typename Container, typename UnaryFunction>
constexpr UnaryFunction for_each(Container&& c, UnaryFunction f)
		noexcept(noexcept(constexprStd::for_each(std::forward<Container>(c).begin(), std::forward<Container>(c).end(),
		                                         std::move(f)))) {
	return std::move(constexprStd::for_each(std::forward<Container>(c).begin(), std::forward<Container>(c).end(),
	                                        std::move(f)));
}

template<typename InputIter, typename Size, typename UnaryFunction>
constexpr InputIter for_each_n(InputIter first, const Size n, UnaryFunction f)
		noexcept(std::is_nothrow_constructible_v<Size, int> && noexcept(std::declval<Size&>() < n) &&
		         noexcept(++std::declval<Size&>(), ++first) && noexcept(f(*first))) {
	for ( Size i = 0; i < n; ++i, ++first ) {
		f(*first);
	} //for ( Size i = 0; i < n; ++i, ++first )
	return first;
}

template<typename InputIter, typename UnaryPredicate>
constexpr auto count_if(InputIter first, const InputIter last, const UnaryPredicate pred)
		noexcept(std::is_nothrow_constructible_v<typename std::iterator_traits<InputIter>::difference_type,
		                                         decltype(0)> &&
		         noexcept(first != last) && noexcept(++first) && noexcept(pred(*first)) &&
		         noexcept(++std::declval<typename std::iterator_traits<InputIter>::difference_type&>())) {
	typename std::iterator_traits<InputIter>::difference_type ret = 0;
	for ( ; first != last; ++first ) {
		if ( pred(*first) ) {
			++ret;
		} //if ( pred(*first) )
	} //for ( ; first != last; ++first )
	return ret;
}

template<typename Container, typename UnaryPredicate>
constexpr auto count_if(Container&& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::count_if(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), pred))) {
	return constexprStd::count_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), pred);
}

template<typename InputIter, typename T>
constexpr auto count(const InputIter first, const InputIter last, const T& t)
		noexcept(noexcept(constexprStd::count_if(first, last, details::cmp::EqualToValue{t}))) {
	return constexprStd::count_if(first, last, details::cmp::EqualToValue{t});
}

template<typename Container, typename T>
constexpr auto count(Container&& c, const T& t)
		noexcept(noexcept(constexprStd::count(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), t))) {
	return constexprStd::count(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), t);
}

template<typename InputIter1, typename InputIter2, typename BinaryPredicate>
constexpr std::pair<InputIter1, InputIter2> mismatch(InputIter1 first1, const InputIter1 last1, InputIter2 first2,
                                                     const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2) && noexcept(!pred(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			break;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1; ++first1, ++first2 )
	return {first1, first2};
}

template<typename InputIter1, typename InputIter2>
constexpr std::pair<InputIter1, InputIter2> mismatch(const InputIter1 first1, const InputIter1 last1,
                                                     const InputIter2 first2)
		noexcept(noexcept(constexprStd::mismatch(first1, last1, first2, details::cmp::Equal{}))) {
	return constexprStd::mismatch(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename InputIter2, typename BinaryPredicate>
constexpr std::pair<decltype(std::begin(std::declval<Container&&>())), InputIter2>
		mismatch(Container&& c, const InputIter2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::mismatch(std::begin(std::forward<Container>(c)),
	                              std::end(std::forward<Container>(c)), first2, pred);
}

template<typename Container, typename InputIter2, std::enable_if_t<details::IsIterV<InputIter2>>* = nullptr>
constexpr std::pair<decltype(std::begin(std::declval<Container&&>())), InputIter2>
		mismatch(Container&& c, const InputIter2 first2)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::mismatch(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), first2);
}

template<typename InputIter1, typename InputIter2, typename BinaryPredicate>
constexpr std::pair<InputIter1, InputIter2> mismatch(InputIter1 first1, const InputIter1 last1,
                                                     InputIter2 first2, const InputIter2 last2,
                                                     const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1 && first2 != last2) && noexcept(++first1, ++first2) &&
		         noexcept(!pred(*first1, *first2))) {
	for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			break;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 )
	return {first1, first2};
}

template<typename InputIter1, typename InputIter2>
constexpr std::pair<InputIter1, InputIter2> mismatch(const InputIter1 first1, const InputIter1 last1,
                                                     const InputIter2 first2, const InputIter2 last2)
		noexcept(noexcept(constexprStd::mismatch(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::mismatch(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2, typename BinaryPredicate>
constexpr auto mismatch(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container1>(c1)),
		                                         std::end(std::forward<Container1>(c1)),
		                                         std::begin(std::forward<Container2>(c2)),
		                                         std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::mismatch(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                              std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)),
	                              pred);
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr auto mismatch(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::mismatch(std::begin(std::forward<Container1>(c1)),
		                                         std::end(std::forward<Container1>(c1)),
		                                         std::begin(std::forward<Container2>(c2)),
		                                         std::end(std::forward<Container2>(c2))))) {
	return constexprStd::mismatch(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                              std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)));
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(IterT1 first1, const IterT1 last1, IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2) && noexcept(pred(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			return false;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1; ++first1, ++first2 )
	return true;
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2, details::cmp::Equal{}))) {
	return constexprStd::equal(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename IterT2, typename BinaryPredicate>
constexpr bool equal(Container&& c, const IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::equal(std::begin(std::forward<Container>(c)),
	                           std::end(std::forward<Container>(c)), first2, pred);
}

template<typename Container, typename IterT2, std::enable_if_t<details::IsIterV<IterT2>>* = nullptr>
constexpr bool equal(Container&& c, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::equal(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), first2);
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2,
                     const BinaryPredicate pred)
		noexcept(noexcept(details::equalImpl(first1, last1, first2, last2, pred))) {
	return details::equalImpl(first1, last1, first2, last2, pred);
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::equal(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2, typename BinaryPredicate>
constexpr bool equal(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container1>(c1)),
		                                      std::end(std::forward<Container1>(c1)),
		                                      std::begin(std::forward<Container2>(c2)),
		                                      std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::equal(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                           std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)), pred);
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool equal(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container1>(c1)),
		                                      std::end(std::forward<Container1>(c1)),
		                                      std::begin(std::forward<Container2>(c2)),
		                                      std::end(std::forward<Container2>(c2))))) {
	return constexprStd::equal(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                           std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)));
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool all_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if_not(first, last, std::move(pred)) == last)) {
	return constexprStd::find_if_not(first, last, std::move(pred)) == last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool all_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::all_of(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::all_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::move(pred));
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool any_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, std::move(pred)) != last)) {
	return constexprStd::find_if(first, last, std::move(pred)) != last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool any_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::any_of(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::any_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::move(pred));
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool none_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, std::move(pred)) == last)) {
	return constexprStd::find_if(first, last, std::move(pred)) == last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool none_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::none_of(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::none_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                             std::move(pred));
}

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr ForwardIter1 find_end(const ForwardIter1 first, const ForwardIter1 last,
                                const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, std::move(pred)))) {
	return details::findEndImpl(first, last, s_first, s_last, std::move(pred));
}

template<typename Container, typename ForwardIter2, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto find_end(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         s_first, s_last, std::move(pred)))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              s_first, s_last, std::move(pred));
}

template<typename Container, typename SearchContainer, typename BinaryPredicate>
constexpr auto find_end(Container&& c, SearchContainer&& s, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         std::begin(std::forward<SearchContainer>(s)),
		                                         std::end(std::forward<SearchContainer>(s)), std::move(pred)))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::begin(std::forward<SearchContainer>(s)),
	                              std::end(std::forward<SearchContainer>(s)), std::move(pred));
}

template<typename ForwardIter1, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter1>>* = nullptr>
constexpr ForwardIter1 find_end(const ForwardIter1 first, const ForwardIter1 last,
                                const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_end(first, last, s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter2>
constexpr auto find_end(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename SearchContainer>
constexpr auto find_end(Container&& c, SearchContainer&& s)
		noexcept(noexcept(constexprStd::find_end(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         std::begin(std::forward<SearchContainer>(s)),
		                                         std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{}))) {
	return constexprStd::find_end(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::begin(std::forward<SearchContainer>(s)),
	                              std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{});
}

template<typename InputIter, typename ForwardIter, typename BinaryPredicate>
constexpr InputIter find_first_of(InputIter first, const InputIter last,
                                  const ForwardIter s_first, const ForwardIter s_last, BinaryPredicate pred)
		noexcept(noexcept(s_first == s_last) && noexcept(first != last) && noexcept(++first) &&
		         std::is_nothrow_copy_constructible_v<ForwardIter> && noexcept(s_first != s_last) &&
		         noexcept(++std::declval<ForwardIter&>()) && noexcept(pred(*first, *s_first))) {
	if ( s_first == s_last ) {
		return last;
	} //if ( s_first == s_last )
	
	for ( ; first != last; ++first ) {
		for ( auto scan = s_first; scan != s_last; ++scan ) {
			if ( pred(*first, *scan) ) {
				return first;
			} //if ( pred(*first, *scan) )
		} //for ( auto scan = s_first; scan != s_last; ++scan )
	} //for ( ; first != last; ++first )
	return last;
}

template<typename Container, typename ForwardIter, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto find_first_of(Container&& c, const ForwardIter s_first, const ForwardIter s_last, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)),
		                                              s_first, s_last, std::move(pred)))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   s_first, s_last, std::move(pred));
}

template<typename Container, typename SearchContainer, typename BinaryPredicate>
constexpr auto find_first_of(Container&& c, SearchContainer&& s, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)),
		                                              std::begin(std::forward<SearchContainer>(s)),
		                                              std::end(std::forward<SearchContainer>(s)), std::move(pred)))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   std::begin(std::forward<SearchContainer>(s)),
	                                   std::end(std::forward<SearchContainer>(s)), std::move(pred));
}

template<typename InputIter, typename ForwardIter, std::enable_if_t<details::IsIterV<InputIter>>* = nullptr>
constexpr InputIter find_first_of(const InputIter first, const InputIter last,
                                  const ForwardIter s_first, const ForwardIter s_last)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_first_of(first, last, s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter>
constexpr auto find_first_of(Container&& c, const ForwardIter s_first, const ForwardIter s_last)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)),
		                                              s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename SearchContainer>
constexpr auto find_first_of(Container&& c, SearchContainer&& s)
		noexcept(noexcept(constexprStd::find_first_of(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)),
		                                         std::begin(std::forward<SearchContainer>(s)),
		                                         std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{}))) {
	return constexprStd::find_first_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::begin(std::forward<SearchContainer>(s)),
	                              std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{});
}

template<typename ForwardIter, typename BinaryPredicate>
constexpr ForwardIter adjacent_find(ForwardIter first, const ForwardIter last, BinaryPredicate pred)
		noexcept(noexcept(first == last) && noexcept(constexprStd::next(first)) && noexcept(first != last) &&
		         noexcept(++first, ++first) && noexcept(pred(*first, *first))) {
	if ( first == last ) {
		return last;
	} //if ( first == last )
	
	for ( auto scan = constexprStd::next(first); scan != last; ++scan, ++first ) {
		if ( pred(*first, *scan) ) {
			return first;
		} //if ( pred(*first, *scan) )
	} //for ( auto scan = constexprStd::next(first); scan != last; ++scan, ++first )
	return last;
}

template<typename Container, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto adjacent_find(Container&& c, BinaryPredicate pred)
			noexcept(noexcept(constexprStd::adjacent_find(std::begin(std::forward<Container>(c)),
			                                              std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::adjacent_find(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   std::move(pred));
}

template<typename ForwardIter, std::enable_if_t<details::IsIterV<ForwardIter>>* = nullptr>
constexpr ForwardIter adjacent_find(const ForwardIter first, const ForwardIter last)
		noexcept(noexcept(constexprStd::adjacent_find(first, last, details::cmp::Equal{}))) {
	return constexprStd::adjacent_find(first, last, details::cmp::Equal{});
}

template<typename Container>
constexpr auto adjacent_find(Container&& c)
		noexcept(noexcept(constexprStd::adjacent_find(std::forward<Container>(c), details::cmp::Equal{}))) {
	return constexprStd::adjacent_find(std::forward<Container>(c), details::cmp::Equal{});
}

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr ForwardIter1 search(ForwardIter1 first, const ForwardIter1 last,
                              const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(first != last) && noexcept(++first) && std::is_nothrow_copy_constructible_v<ForwardIter1> &&
		         std::is_nothrow_copy_constructible_v<ForwardIter2> &&
		         noexcept(first != last && std::declval<ForwardIter2&>() != s_last &&
		                  pred(*first, *std::declval<ForwardIter2&>())) &&
		         noexcept(++first, ++std::declval<ForwardIter2&>()) &&
		         noexcept(std::declval<ForwardIter2&>() == s_last) && noexcept(first == last)) {
	for ( ; first != last; ++first ) {
		auto scan = first;
		auto cmp  = s_first;
		for ( ; scan != last && cmp != s_last && pred(*scan, *cmp); ++scan, ++cmp ) {
			
		} //for ( ; scan != last && cmp != s_last && pred(*scan, *cmp); ++scan, ++cmp )
		
		if ( cmp == s_last ) {
			return first;
		} //if ( cmp == s_last )
		
		if ( scan == last ) {
			return last;
		} //if ( scan == last )
	} //for ( ; first != last; ++first )
	return last;
}

template<typename Container, typename ForwardIter2, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container>>>* = nullptr>
constexpr auto search(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       s_first, s_last, std::move(pred)))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            s_first, s_last, std::move(pred));
}

template<typename Container, typename SearchContainer, typename BinaryPredicate>
constexpr auto search(Container&& c, SearchContainer&& s, BinaryPredicate pred)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       std::begin(std::forward<SearchContainer>(s)),
		                                       std::end(std::forward<SearchContainer>(s)), std::move(pred)))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::begin(std::forward<SearchContainer>(s)),
	                            std::end(std::forward<SearchContainer>(s)), std::move(pred));
}

template<typename ForwardIter1, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter1>>* = nullptr>
constexpr ForwardIter1 search(const ForwardIter1 first, const ForwardIter1 last,
                              const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(details::findEndImpl(first, last, s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::search(first, last, s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter2>
constexpr auto search(Container&& c, const ForwardIter2 s_first, const ForwardIter2 s_last)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       s_first, s_last, details::cmp::Equal{}))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            s_first, s_last, details::cmp::Equal{});
}

template<typename Container, typename SearchContainer,
         std::enable_if_t<std::negation_v<details::IsSearcher<SearchContainer,
                                                              decltype(std::begin(std::declval<Container&&>()))>>>* =
         nullptr>
constexpr auto search(Container&& c, SearchContainer&& s)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)),
		                                       std::begin(std::forward<SearchContainer>(s)),
		                                       std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{}))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::begin(std::forward<SearchContainer>(s)),
	                            std::end(std::forward<SearchContainer>(s)), details::cmp::Equal{});
}

template<typename ForwardIter, typename Searcher>
constexpr ForwardIter search(const ForwardIter first, const ForwardIter last, const Searcher& searcher)
		noexcept(noexcept(searcher(first, last).first)) {
	return searcher(first, last).first;
}

template<typename Container, typename Searcher,
         std::enable_if_t<details::IsSearcherV<Searcher, decltype(std::begin(std::declval<Container&&>()))>>* = nullptr>
constexpr auto search(Container&& c, const Searcher& searcher)
		noexcept(noexcept(constexprStd::search(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), searcher))) {
	return constexprStd::search(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), searcher);
}

template<typename ForwardIter, typename Count, typename T, typename BinaryPredicate = std::equal_to<>>
constexpr ForwardIter search_n(ForwardIter first, const ForwardIter last, const Count count, const T& value,
                               BinaryPredicate pred = {})
		noexcept(noexcept(first != last) && std::is_nothrow_copy_constructible_v<ForwardIter> &&
		         std::is_nothrow_constructible_v<Count, int> &&
		         noexcept(std::declval<Count&>() < count && first != last) &&
		         noexcept(++std::declval<Count&>(), ++first) && noexcept(!pred(*first, value)) &&
		         noexcept(std::declval<Count&>() == count) && noexcept(++first) &&
		         std::is_nothrow_copy_assignable_v<ForwardIter>) {
	while ( first != last ) {
		auto scan = first;
		Count i = 0;
		for ( ; i < count && scan != last; ++i, ++scan ) {
			if ( !pred(*scan, value) ) {
				break;
			} //if ( !pred(*scan, value) )
		} //for ( ; i < count && scan != last; ++i, ++scan )
		
		if ( i == count ) {
			return first;
		} //if ( i == count )
		
		if ( scan == last ) {
			return last;
		} //if ( scan == last )
		
		first = ++scan;
	} //while ( first != last )
	return last;
}

template<typename Container, typename Count, typename T, typename BinaryPredicate = std::equal_to<>>
constexpr auto search_n(Container&& c, const Count count, const T& value, BinaryPredicate pred = {})
		noexcept(noexcept(constexprStd::search_n(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), count, value, std::move(pred)))) {
	return constexprStd::search_n(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), count,
	                              value, std::move(pred));
}

/*****                                       Modifying sequence operations                                        *****/

template<typename InputIterator, typename OutputIterator>
constexpr OutputIterator copy(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(*destination = *sourceFirst)) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination ) {
		*destination = *sourceFirst;
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination )
	return destination;
}

template<typename Container, typename OutputIterator>
constexpr OutputIterator copy(Container&& c, const OutputIterator destination)
		noexcept(noexcept(constexprStd::copy(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), destination))) {
	return constexprStd::copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                          destination);
}

template<typename InputIterator, typename OutputIterator, typename UnaryPredicate>
constexpr OutputIterator copy_if(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination,
                                 UnaryPredicate pred)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(pred(*sourceFirst)) && noexcept(*destination = *sourceFirst)) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst ) {
		if ( pred(*sourceFirst) ) {
			*destination = *sourceFirst;
			++destination;
		} //if ( pred(*sourceFirst) )
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst )
	return destination;
}

template<typename Container, typename OutputIterator, typename UnaryPredicate>
constexpr OutputIterator copy_if(Container&& c, const OutputIterator destination, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::copy_if(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), destination, std::move(pred)))) {
	return constexprStd::copy_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                             destination, std::move(pred));
}

template<typename InputIter, typename Size, typename OutputIter>
constexpr OutputIter copy_n(InputIter first, Size count, OutputIter result)
		noexcept(noexcept(count-- > 0) && noexcept(*result = *first) && noexcept(++result) && noexcept(++first)) {
	while ( count-- > 0 ) {
		*result = *first;
		++result;
		++first;
	} //while ( count-- > 0 )
	return result;
}

template<typename BidirIter1, typename BidirIter2>
constexpr BidirIter2 copy_backward(const BidirIter1 first, BidirIter1 last, BidirIter2 d_last)
		noexcept(noexcept(first != last) && noexcept(*--d_last = *--last)) {
	while ( first != last ) {
		*--d_last = *--last;
	} //while ( first != last )
	return d_last;
}

template<typename Container, typename BidirIter2>
constexpr BidirIter2 copy_backward(Container&& c, const BidirIter2 d_last)
		noexcept(noexcept(constexprStd::copy_backward(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)), d_last))) {
	return constexprStd::copy_backward(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   d_last);
}

template<typename InputIterator, typename OutputIterator>
constexpr OutputIterator move(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(*destination = std::move(*sourceFirst))) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination ) {
		*destination = std::move(*sourceFirst);
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination )
	return destination;
}

template<typename Container, typename OutputIterator>
constexpr OutputIterator move(Container&& c, const OutputIterator destination)
		noexcept(noexcept(constexprStd::move(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), destination))) {
	return constexprStd::move(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                          destination);
}

template<typename BidirIter1, typename BidirIter2>
constexpr BidirIter2 move_backward(const BidirIter1 first, BidirIter1 last, BidirIter2 d_last)
		noexcept(noexcept(first != last) && noexcept(*--d_last = std::move(*--last))) {
	while ( first != last ) {
		*--d_last = std::move(*--last);
	} //while ( first != last )
	return d_last;
}

template<typename Container, typename BidirIter2>
constexpr BidirIter2 move_backward(Container&& c, const BidirIter2 d_last)
		noexcept(noexcept(constexprStd::move_backward(std::begin(std::forward<Container>(c)),
		                                              std::end(std::forward<Container>(c)), d_last))) {
	return constexprStd::move_backward(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                   d_last);
}

template<typename ForwardIter, typename T>
constexpr void fill(ForwardIter first, const ForwardIter last, const T& value)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(*first = value)) {
	for ( ; first != last; ++first ) {
		*first = value;
	} //for ( ; first != last; ++first )
	return;
}

template<typename Container, typename T>
constexpr void fill(Container&& c, const T& value)
		noexcept(noexcept(constexprStd::fill(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), value))) {
	constexprStd::fill(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), value);
	return;
}

template<typename OutputIter, typename Size, typename T>
constexpr OutputIter fill_n(OutputIter first, Size count, const T& value)
		noexcept(noexcept(count-- > 0) && noexcept(*first = value) && noexcept(++first)) {
	while ( count-- > 0 ) {
		*first = value;
		++first;
	} //while ( count-- > 0 )
	return first;
}

template<typename ForwardIter, typename OutputIter, typename UnaryOperation>
constexpr OutputIter transform(ForwardIter first, const ForwardIter last, OutputIter d_first, UnaryOperation unary_op)
		noexcept(noexcept(first != last) && noexcept(++first, ++d_first) && noexcept(*d_first = unary_op(*first))) {
	for ( ; first != last; ++first, ++d_first ) {
		*d_first = unary_op(*first);
	} //for ( ; first != last; ++first, ++d_first )
	return d_first;
}

template<typename Container, typename OutputIter, typename UnaryOperation>
constexpr auto transform(Container&& c, const OutputIter d_first, UnaryOperation unary_op)
		noexcept(noexcept(constexprStd::transform(std::begin(std::forward<Container>(c)),
		                                          std::end(std::forward<Container>(c)),
		                                          d_first, std::move(unary_op)))) {
	return constexprStd::transform(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                               d_first, std::move(unary_op));
}

template<typename ForwardIter1, typename ForwardIter2, typename OutputIter, typename BinaryOperation>
constexpr OutputIter transform(ForwardIter1 first1, const ForwardIter1 last1, ForwardIter2 first2, OutputIter d_first,
                               BinaryOperation binary_op)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2, ++d_first) &&
		         noexcept(*d_first = binary_op(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2, ++d_first ) {
		*d_first = binary_op(*first1, *first2);
	} //for ( ; first1 != last1; ++first1, ++first2, ++d_first )
	return d_first;
}

template<typename Container, typename ForwardIter2, typename OutputIter, typename BinaryOperation>
constexpr auto transform(Container&& c, const ForwardIter2 first2, const OutputIter d_first, BinaryOperation binary_op)
		noexcept(noexcept(constexprStd::transform(std::begin(std::forward<Container>(c)),
		                                          std::end(std::forward<Container>(c)),
		                                          first2, d_first, std::move(binary_op)))) {
	return constexprStd::transform(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                               first2, d_first, std::move(binary_op));
}

template<typename ForwardIter, typename Generator>
constexpr void generate(ForwardIter first, const ForwardIter last, Generator gen)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(*first = gen())) {
	for ( ; first != last; ++first ) {
		*first = gen();
	} //for ( ; first != last; ++first )
	return;
}

template<typename Container, typename Generator>
constexpr auto generate(Container&& c, Generator gen)
		noexcept(noexcept(constexprStd::generate(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), std::move(gen)))) {
	return constexprStd::generate(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                              std::move(gen));
}

template<typename OutputIter, typename Size, typename Generator>
constexpr OutputIter generate_n(OutputIter first, Size count, Generator g)
		noexcept(noexcept(count-- > 0) && noexcept(*first = g()) && noexcept(++first)) {
	while ( count-- > 0 ) {
		*first = g();
		++first;
	} //while ( count-- > 0 )
	return first;
}

template<typename ForwardIter, typename UnaryPredicate>
constexpr ForwardIter remove_if(ForwardIter first, const ForwardIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, pred)) && std::is_nothrow_move_assignable_v<ForwardIter> &&
		         noexcept(first == last) && noexcept(constexprStd::next(first)) &&
		         std::is_nothrow_move_constructible_v<ForwardIter> && noexcept(first != last) && noexcept(++first) &&
		         noexcept(!pred(*first)) &&
		         std::is_nothrow_move_assignable_v<typename std::iterator_traits<ForwardIter>::value_type>) {
	first = constexprStd::find_if(first, last, pred);
	if ( first == last ) {
		return first;
	} //if ( first == last )
	
	for ( auto scan = constexprStd::next(first); scan != last; ++scan ) {
		if ( !pred(*scan) ) {
			*first = std::move(*scan);
			++first;
		} //if ( !pred(*scan) )
	} //for ( auto scan = constexprStd::next(first); scan != last; ++scan )
	return first;
}

template<typename Container, typename UnaryPredicate>
constexpr auto remove_if(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::remove_if(std::begin(std::forward<Container>(c)),
		                                          std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::remove_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                               std::move(pred));
}

template<typename ForwardIter, typename T>
constexpr ForwardIter remove(const ForwardIter first, const ForwardIter last, const T& value)
		noexcept(noexcept(constexprStd::remove_if(first, last, details::cmp::EqualToValue{value}))){
	return constexprStd::remove_if(first, last, details::cmp::EqualToValue{value});
}

template<typename Container, typename T>
constexpr auto remove(Container&& c, const T& value)
		noexcept(noexcept(constexprStd::remove(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), value))) {
	return constexprStd::remove(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), value);
}

template<typename InputIter, typename OutputIter, typename UnaryPredicate>
constexpr OutputIter remove_copy_if(const InputIter first, const InputIter last, const OutputIter d_first,
                                    UnaryPredicate pred)
		noexcept(noexcept(constexprStd::copy_if(first, last, d_first, constexprStd::not_fn(std::move(pred))))) {
	return constexprStd::copy_if(first, last, d_first, constexprStd::not_fn(std::move(pred)));
}

template<typename Container, typename OutputIter, typename UnaryPredicate>
constexpr OutputIter remove_copy_if(Container&& c, const OutputIter d_first, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::remove_copy_if(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), d_first,
		                                               std::move(pred)))) {
	return constexprStd::remove_copy_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                    d_first, std::move(pred));
}

template<typename ForwardIter, typename OutputIter, typename T>
constexpr OutputIter remove_copy(const ForwardIter first, const ForwardIter last, const OutputIter d_first,
                                  const T& value)
		noexcept(noexcept(constexprStd::remove_copy_if(first, last, d_first, details::cmp::EqualToValue{value}))){
	return constexprStd::remove_copy_if(first, last, d_first, details::cmp::EqualToValue{value});
}

template<typename Container, typename OutputIter, typename T>
constexpr OutputIter remove_copy(Container&& c, const OutputIter d_first, const T& value)
		noexcept(noexcept(constexprStd::remove_copy(std::begin(std::forward<Container>(c)),
		                                            std::end(std::forward<Container>(c)), d_first, value))) {
	return constexprStd::remove_copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                 d_first, value);
}

template<typename ForwardIter, typename UnaryPredicate, typename T>
constexpr void replace_if(ForwardIter first, const ForwardIter last, UnaryPredicate pred, const T& newValue)
		noexcept(noexcept(first != last) && noexcept(++first) && noexcept(pred(*first)) &&
		         noexcept(*first = newValue)) {
	for ( ; first != last; ++first ) {
		if ( pred(*first) ) {
			*first = newValue;
		} //if ( pred(*first) )
	} //for ( ; first != last; ++first )
	return;
}

template<typename Container, typename UnaryPredicate, typename T>
constexpr void replace_if(Container&& c, UnaryPredicate pred, const T& newValue)
		noexcept(noexcept(constexprStd::replace_if(std::begin(std::forward<Container>(c)),
		                                           std::end(std::forward<Container>(c)), std::move(pred), newValue))) {
	constexprStd::replace_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                         std::move(pred), newValue);
	return;
}

template<typename ForwardIter, typename T>
constexpr void replace(const ForwardIter first, const ForwardIter last, const T& oldValue, const T& newValue)
		noexcept(noexcept(constexprStd::replace_if(first, last, details::cmp::EqualToValue{oldValue}, newValue))){
	constexprStd::replace_if(first, last, details::cmp::EqualToValue{oldValue}, newValue);
	return;
}

template<typename Container, typename T>
constexpr void replace(Container&& c, const T& oldValue, const T& newValue)
		noexcept(noexcept(constexprStd::replace(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), oldValue, newValue))) {
	constexprStd::replace(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), oldValue,
	                      newValue);
	return;
}

template<typename InputIter, typename OutputIter, typename UnaryPredicate, typename T>
constexpr OutputIter replace_copy_if(const InputIter first, const InputIter last, const OutputIter d_first,
                                     UnaryPredicate pred, const T& newValue)
		noexcept(noexcept(constexprStd::transform(first, last, d_first,
                                                  details::ReplaceCopyIf{std::move(pred), newValue}))) {
	return constexprStd::transform(first, last, d_first, details::ReplaceCopyIf{std::move(pred), newValue});
}

template<typename Container, typename OutputIter, typename UnaryPredicate, typename T>
constexpr OutputIter replace_copy_if(Container&& c, const OutputIter d_first, UnaryPredicate pred, const T& newValue)
		noexcept(noexcept(constexprStd::replace_copy_if(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), d_first,
		                                               std::move(pred), newValue))) {
	return constexprStd::replace_copy_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                     d_first, std::move(pred), newValue);
}

template<typename InputIter, typename OutputIter, typename T>
constexpr OutputIter replace_copy(const InputIter first, const InputIter last, const OutputIter d_first,
                                  const T& oldValue, const T& newValue)
		noexcept(noexcept(constexprStd::replace_copy_if(first, last, d_first, details::cmp::EqualToValue{oldValue},
		                                                newValue))){
	return constexprStd::replace_copy_if(first, last, d_first, details::cmp::EqualToValue{oldValue}, newValue);
}

template<typename Container, typename OutputIter, typename T>
constexpr OutputIter replace_copy(Container&& c, const OutputIter d_first, const T& oldValue, const T& newValue)
		noexcept(noexcept(constexprStd::replace_copy(std::begin(std::forward<Container>(c)),
		                                             std::end(std::forward<Container>(c)), d_first, oldValue,
		                                             newValue))) {
	return constexprStd::replace_copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                  d_first, oldValue, newValue);
}

template<typename ForwardIter1, typename ForwardIter2>
constexpr void iter_swap(const ForwardIter1 iter1, const ForwardIter2 iter2)
		noexcept(std::is_nothrow_swappable_with_v<typename std::iterator_traits<ForwardIter1>::value_type,
		                                          typename std::iterator_traits<ForwardIter2>::value_type>) {
	constexprStd::swap(*iter1, *iter2);
	return;
}

template<typename ForwardIter1, typename ForwardIter2>
constexpr ForwardIter2 swap_ranges(ForwardIter1 first1, const ForwardIter1 last1, ForwardIter2 first2)
		noexcept(noexcept(first1 != last1) && noexcept(static_cast<void>(++first1), ++first2) &&
		         noexcept(constexprStd::iter_swap(first1, first2))) {
	for ( ; first1 != last1; static_cast<void>(++first1), ++first2 ) {
		constexprStd::iter_swap(first1, first2);
	} //for ( ; first1 != last1; static_cast<void>(++first1), ++first2 )
	return first2;
}

template<typename Container, typename ForwardIter2>
constexpr ForwardIter2 swap_ranges(Container&& c, ForwardIter2 first2)
		noexcept(noexcept(constexprStd::swap_ranges(std::begin(std::forward<Container>(c)),
		                                            std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::swap_ranges(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                 first2);
}

template<typename BidirIter>
constexpr void reverse(BidirIter first, BidirIter last)
		noexcept(noexcept(first == last) && noexcept(first != last && first != --last) && noexcept(++first) &&
		         noexcept(constexprStd::iter_swap(first, last))) {
	if ( first == last ) {
		return;
	} //if ( first == last )
	
	for ( ; first != last && first != --last; ++first ) {
		constexprStd::iter_swap(first, last);
	} //for ( ; first != last && first != --last; ++first )
	return;
}

template<typename Container>
constexpr void reverse(Container&& c)
		noexcept(noexcept(constexprStd::reverse(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c))))) {
	constexprStd::reverse(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)));
	return;
}

template<typename BidirIter, typename OutputIter>
constexpr OutputIter reverse_copy(const BidirIter first, const BidirIter last, const OutputIter d_first)
		noexcept(noexcept(constexprStd::copy(std::make_reverse_iterator(last), std::make_reverse_iterator(first),
		                                     d_first))) {
	return constexprStd::copy(std::make_reverse_iterator(last), std::make_reverse_iterator(first), d_first);
}

template<typename Container, typename OutputIter>
constexpr OutputIter reverse_copy(Container&& c, const OutputIter d_first)
		noexcept(noexcept(constexprStd::reverse_copy(std::begin(std::forward<Container>(c)),
		                                             std::end(std::forward<Container>(c)), d_first))) {
	return constexprStd::reverse_copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                  d_first);
}

template<typename ForwardIter>
constexpr ForwardIter rotate(ForwardIter first, ForwardIter n_first, const ForwardIter last) {
	//Copied from cppreference, my solutions didn't work out. Altough I don't think that this is linear.
	if ( first == n_first ) {
		return last;
	} //if ( first == n_first )
	
	if ( n_first == last ) {
		return first;
	} //if ( n_first == last )
	
	auto next = n_first;
	
	do { //while ( next != last )
		constexprStd::iter_swap(first++, next++);
		if ( first == n_first ) {
			n_first = next;
		} //if ( first == n_first )
	} while ( next != last );
	
	auto ret = first;
	
	for ( next = n_first; next != last; ) {
		constexprStd::iter_swap(first++, next++);
		if ( first == n_first ) {
			n_first = next;
		} //if ( first == n_first )
		else if ( next == last ) {
			next = n_first;
		} //else if ( next == last )
	} //for ( next = n_first; next != last; )
	return ret;
}

template<typename ForwardIter, typename OutputIter>
constexpr OutputIter rotate_copy(const ForwardIter first, const ForwardIter n_first, const ForwardIter last,
                                 const OutputIter d_first)
		noexcept(noexcept(constexprStd::copy(first, n_first, constexprStd::copy(n_first, last, d_first)))) {
	return constexprStd::copy(first, n_first, constexprStd::copy(n_first, last, d_first));
}

template<typename ForwardIter, typename BinaryPredicate = std::equal_to<>>
constexpr ForwardIter unique(ForwardIter first, const ForwardIter last, BinaryPredicate pred = {})
noexcept(noexcept(constexprStd::adjacent_find(first, last, pred)) && noexcept(first == last) &&
         noexcept(constexprStd::next(first)) && std::is_nothrow_move_assignable_v<ForwardIter> &&
         noexcept(first != last) && noexcept(++first) && noexcept(!pred(*first, *first)) &&
         std::is_nothrow_move_assignable_v<typename std::iterator_traits<ForwardIter>::value_type>) {
	auto ret = constexprStd::adjacent_find(first, last, pred);
	if ( ret == last ) {
		return ret;
	} //if ( ret == last )
	
	for ( first = constexprStd::next(ret); first != last; ++first ) {
		if ( !pred(*ret, *first) ) {
			*++ret = std::move(*first);
		} //if ( !pred(*ret, *first) )
	} //for ( first = constexprStd::next(ret); first != last; ++first )
	return ++ret;
}

template<typename Container, typename BinaryPredicate = std::equal_to<>>
constexpr auto unique(Container&& c, BinaryPredicate pred = {})
		noexcept(noexcept(constexprStd::unique(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::unique(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::move(pred));
}

template<typename InputIter, typename OutputIter, typename BinaryPredicate = std::equal_to<>>
constexpr OutputIter unique_copy(const InputIter first, const InputIter last, const OutputIter d_first,
                                 BinaryPredicate pred = {})
		noexcept(noexcept(first == last) &&
		         noexcept(details::uniqueCopyImpl(first, last, d_first, std::move(pred),
		                                          details::iteratorCategory<InputIter>))) {
	if ( first == last ) {
		return d_first;
	} //if ( first == last )
	return details::uniqueCopyImpl(first, last, d_first, std::move(pred), details::iteratorCategory<InputIter>);
}

template<typename Container, typename OutputIter, typename BinaryPredicate = std::equal_to<>>
constexpr OutputIter unique_copy(Container&& c, const OutputIter d_first, BinaryPredicate pred = {})
		noexcept(noexcept(constexprStd::unique_copy(std::begin(std::forward<Container>(c)),
		                                            std::end(std::forward<Container>(c)), d_first, std::move(pred)))) {
	return constexprStd::unique_copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                 d_first, std::move(pred));
}

/*****                                          Partitioning Operations                                           *****/

template<typename InputIter, typename UnaryPredicate>
constexpr bool is_partitioned(InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(first != last && pred(*first)) && noexcept(++first) && noexcept(first == last) &&
		         noexcept(constexprStd::find_if(first, last, pred) == last)) {
	for ( ; first != last && pred(*first); ++first ) {
		
	} //for ( ; first != last && pred(*first); ++first )
	
	if ( first == last ) {
		return true;
	} //if ( first == last )
	return constexprStd::find_if(first, last, pred) == last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool is_partitioned(const Container& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::is_partitioned(std::begin(c), std::end(c), std::move(pred)))) {
	return constexprStd::is_partitioned(std::begin(c), std::end(c), std::move(pred));
}

template<typename ForwardIter, typename UnaryPredicate>
constexpr ForwardIter partition(const ForwardIter first, const ForwardIter last, UnaryPredicate pred)
		noexcept(noexcept(details::partitionImpl(first, last, std::move(pred),
		                                         details::iteratorCategory<ForwardIter>))) {
	return details::partitionImpl(first, last, std::move(pred), details::iteratorCategory<ForwardIter>);
}

template<typename Container, typename UnaryPredicate>
constexpr auto partition(Container& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::partition(std::begin(c), std::end(c), std::move(pred)))) {
	return constexprStd::partition(std::begin(c), std::end(c), std::move(pred));
}

template<typename InputIter, typename OutputIter1, typename OutputIter2, typename UnaryPredicate>
constexpr std::pair<OutputIter1, OutputIter2> partition_copy(InputIter first, const InputIter last,
                                                             OutputIter1 d_first_true, OutputIter2 d_first_false,
                                                             UnaryPredicate pred)
		noexcept(noexcept(first != last) && noexcept(++first) &&
		         std::is_nothrow_copy_constructible_v<details::typeOf<InputIter>> &&
		         noexcept(pred(std::declval<details::typeOf<InputIter>&>())) &&
		         noexcept(*d_first_true = std::declval<details::typeOf<InputIter>&&>()) && noexcept(++d_first_true) &&
		         noexcept(*d_first_false = std::declval<details::typeOf<InputIter>&&>()) && noexcept(++d_first_false)) {
	for ( ; first != last; ++first ) {
		auto element = *first;
		if ( pred(element) ) {
			*d_first_true = std::move(element);
			++d_first_true;
		} //if ( pred(element) )
		else {
			*d_first_false = std::move(element);
			++d_first_false;
		} //else -> if ( pred(element) )
	} //for ( ; first != last; ++first )
	return {d_first_true, d_first_false};
}

template<typename Container, typename OutputIter1, typename OutputIter2, typename UnaryPredicate>
constexpr std::pair<OutputIter1, OutputIter2> partition_copy(const Container& c, const OutputIter1 d_first_true,
                                                             const OutputIter2 d_first_false, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::partition_copy(std::begin(c), std::end(c), d_first_true, d_first_false,
		                                               std::move(pred)))) {
	return constexprStd::partition_copy(std::begin(c), std::end(c), d_first_true, d_first_false, std::move(pred));
}

template<typename BidirIter, typename UnaryPredicate>
constexpr BidirIter stable_partition(BidirIter first, const BidirIter last, UnaryPredicate pred)
noexcept(true) {
	first = constexprStd::find_if_not(first, last, pred);
	auto iter = constexprStd::next(first);
	while ( iter != last ) {
		iter = constexprStd::find_if(iter, last, pred);
		if ( iter == last ) {
			break;
		} //if ( iter == last )
		details::rotateOneRight(first, ++iter);
		++first;
	} //while ( iter != last )
	return first;
}

template<typename Container, typename UnaryPredicate>
constexpr auto stable_partition(Container& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::stable_partition(std::begin(c), std::end(c), std::move(pred)))) {
	return constexprStd::stable_partition(std::begin(c), std::end(c), std::move(pred));
}

template<typename ForwardIterator, typename UnaryPredicate>
constexpr ForwardIterator partition_point(const ForwardIterator first, const ForwardIterator last, UnaryPredicate pred)
		noexcept(noexcept(details::partitionPointImpl(first, last, std::move(pred),
		                                              details::iteratorCategory<ForwardIterator>))) {
	return details::partitionPointImpl(first, last, std::move(pred), details::iteratorCategory<ForwardIterator>);
}

template<typename Container, typename UnaryPredicate>
constexpr auto partition_point(const Container& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::partition_point(std::begin(c), std::end(c), std::move(pred)))) {
	return constexprStd::partition_point(std::begin(c), std::end(c), std::move(pred));
}

/*****                                            Sorting operations                                              *****/

template<typename ForwardIter, typename Compare = std::less<>>
constexpr ForwardIter is_sorted_until(ForwardIter first, const ForwardIter last, Compare cmp = {})
		noexcept(noexcept(first == last) && noexcept(first++) && std::is_nothrow_move_constructible_v<ForwardIter> &&
		         noexcept(first != last && !cmp(*first, *first)) && noexcept(++first, ++first)) {
	if ( first == last ) {
		return first;
	} //if ( first == last )
	
	for ( auto old = first++; first != last && !cmp(*first, *old); ++first, ++old ) {
		
	} //for ( auto old = first++; first != last && !cmp(*first, *old); ++first, ++old )
	return first;
}

template<typename Container, typename Compare = std::less<>>
constexpr auto is_sorted_until(const Container& c, Compare cmp = {})
		noexcept(noexcept(constexprStd::is_sorted_until(std::begin(c), std::end(c), std::move(cmp)))) {
	return constexprStd::is_sorted_until(std::begin(c), std::end(c), std::move(cmp));
}

template<typename ForwardIter, typename Compare = std::less<>>
constexpr bool is_sorted(const ForwardIter first, const ForwardIter last, Compare cmp = {})
		noexcept(noexcept(constexprStd::is_sorted_until(first, last, std::move(cmp)) == last)) {
	return constexprStd::is_sorted_until(first, last, std::move(cmp)) == last;
}

template<typename Container, typename Compare = std::less<>>
constexpr bool is_sorted(const Container& c, Compare cmp = {})
		noexcept(noexcept(constexprStd::is_sorted(std::begin(c), std::end(c), std::move(cmp)))) {
	return constexprStd::is_sorted(std::begin(c), std::end(c), std::move(cmp));
}

template<typename RandIter, typename Compare = std::less<>>
constexpr void sort(const RandIter first, const RandIter last, Compare cmp = {})
		noexcept(noexcept(constexprStd::make_heap(first, last, cmp)) &&
		         noexcept(constexprStd::sort_heap(first, last, std::move(cmp)))) {
	constexprStd::make_heap(first, last, cmp);
	constexprStd::sort_heap(first, last, std::move(cmp));
	return;
}

template<typename Container, typename Compare = std::less<>>
constexpr void sort(Container& c, Compare cmp = {})
		noexcept(noexcept(constexprStd::sort(std::begin(c), std::end(c), std::move(cmp)))) {
	constexprStd::sort(std::begin(c), std::end(c), std::move(cmp));
	return;
}

template<typename RandIter, typename Compare = std::less<>>
constexpr void nth_element(RandIter first, const RandIter nth, RandIter last, Compare cmp = {})
		noexcept(noexcept(first != last) && noexcept(details::moveMedianOfThreeToEnd(first, last, cmp)) &&
		         std::is_nothrow_move_constructible_v<RandIter> &&
		         noexcept(details::partitionByElement(first, first, cmp)) && noexcept(first == nth) &&
		         noexcept(first < nth) && std::is_nothrow_copy_assignable_v<RandIter> && noexcept(++first)) {
	while ( first != last ) {
		auto end = details::moveMedianOfThreeToEnd(first, last, cmp);
		auto cut = details::partitionByElement(first, end, cmp);
		
		if ( cut == nth ) {
			return;
		} //if ( cut == nth )
		
		if ( cut < nth ) {
			first = ++cut;
		} //if ( cut < nth )
		else {
			last = cut;
		} //else -> if ( cut < nth )
	} //while ( first != last )
	return;
}

template<typename RandIter, typename Compare = std::less<>>
constexpr void partial_sort(const RandIter first, const RandIter middle, const RandIter last, Compare cmp = {})
		noexcept(noexcept(constexprStd::nth_element(first, middle, last, cmp)) &&
		         noexcept(constexprStd::sort(first, middle, std::move(cmp)))) {
	constexprStd::nth_element(first, middle, last, cmp);
	constexprStd::sort(first, middle, std::move(cmp));
	return;
}

/*****                                             Heap operations                                                *****/

template<typename RandIter, typename Compare = std::less<>,
         typename Dist = typename std::iterator_traits<RandIter>::difference_type>
constexpr RandIter is_heap_until(const RandIter first, const RandIter last, Compare cmp)
		noexcept(noexcept(constexprStd::distance(first, last)) && std::is_nothrow_move_constructible_v<Dist> &&
		         noexcept(std::declval<const Dist&>() / 2) && std::is_nothrow_constructible_v<Dist, int> &&
		         std::is_nothrow_copy_constructible_v<RandIter> &&
		         noexcept(std::declval<Dist&>() < std::declval<const Dist&>()) &&
		         noexcept(++std::declval<Dist&>(), ++std::declval<RandIter&>()) &&
		         noexcept(std::declval<Dist&>() * 2 + 1) &&
		         noexcept(constexprStd::next(first, std::declval<const Dist&>())) &&
		         std::is_nothrow_move_constructible_v<RandIter> &&
		         noexcept(cmp(*std::declval<RandIter&>(), *std::declval<RandIter&>())) &&
		         noexcept(++std::declval<RandIter&>() != last)) {
	const auto n = constexprStd::distance(first, last);
	const auto upperBound = n / 2;
	Dist currentIndex = 0;
	
	for ( auto current = first; currentIndex < upperBound; ++currentIndex, ++current ) {
		const auto childIndex = currentIndex * 2 + 1;
		auto child = constexprStd::next(first, childIndex);
		
		if ( cmp(*current, *child) ) {
			return child;
		} //if ( cmp(*current, *child) )
		
		if ( ++child != last ) {
			if ( cmp(*current, *child) ) {
				return child;
			} //if ( cmp(*current, *child) )
		} //if ( ++child != last )
	} //for ( auto current = first; currentIndex < upperBound; ++currentIndex, ++current )
	return last;
}

template<typename Container, typename Compare = std::less<>>
constexpr auto is_heap_until(const Container& c, Compare cmp = {})
		noexcept(noexcept(constexprStd::is_heap_until(std::begin(c), std::end(c), std::move(cmp)))) {
	return constexprStd::is_heap_until(std::begin(c), std::end(c), std::move(cmp));
}

template<typename RandIter, typename Compare = std::less<>>
constexpr bool is_heap(const RandIter first, const RandIter last, Compare cmp = {})
		noexcept(noexcept(constexprStd::is_heap_until(first, last, std::move(cmp)) == last)) {
	return constexprStd::is_heap_until(first, last, std::move(cmp)) == last;
}

template<typename Container, typename Compare = std::less<>>
constexpr auto is_heap(const Container& c, Compare cmp = {})
		noexcept(noexcept(constexprStd::is_heap(std::begin(c), std::end(c), std::move(cmp)))) {
	return constexprStd::is_heap(std::begin(c), std::end(c), std::move(cmp));
}

template<typename RandIter, typename Compare = std::less<>,
         typename Dist = typename std::iterator_traits<RandIter>::difference_type>
constexpr void push_heap(const RandIter first, RandIter last, Compare cmp)
		noexcept(noexcept(first == last) && noexcept(constexprStd::distance(first, --last)) &&
		         std::is_nothrow_move_constructible_v<Dist> && std::is_nothrow_constructible_v<bool, Dist&> &&
		         noexcept((std::declval<Dist&>() - 1) / 2) &&
		         noexcept(constexprStd::next(first, std::declval<Dist&>())) &&
		         noexcept(constexprStd::next(first, std::declval<const Dist&>())) &&
		         noexcept(cmp(*first, *first)) && noexcept(constexprStd::iter_swap(first, first)) &&
		         std::is_nothrow_copy_assignable_v<Dist>) {
	if ( first == last ) {
		return;
	} //if ( first == last )
	
	Dist index = constexprStd::distance(first, --last);
	
	while ( index ) {
		const Dist parentIndex    = (index - 1) / 2;
		const RandIter iter       = constexprStd::next(first, index);
		const RandIter parentIter = constexprStd::next(first, parentIndex);
		
		if ( cmp(*iter, *parentIter) ) {
			break;
		} //if ( cmp(*iter, *parentIter) )
		else {
			constexprStd::iter_swap(iter, parentIter);
			index = parentIndex;
		} //else -> if ( cmp(*iter, *parentIter) )
	} //while ( index )
	return;
}

template<typename RandIter, typename Compare = std::less<>>
constexpr void make_heap(const RandIter first, const RandIter last, Compare cmp)
		noexcept(noexcept(constexprStd::is_heap_until(first, last, cmp)) &&
		         std::is_nothrow_move_constructible_v<RandIter> && noexcept(std::declval<RandIter&>()++ != last) &&
		         noexcept(constexprStd::push_heap(first, std::declval<RandIter&>(), cmp))) {
	for ( auto iter = constexprStd::is_heap_until(first, last, cmp); iter++ != last; ) {
		constexprStd::push_heap(first, iter, cmp);
	} //for ( auto iter = constexprStd::is_heap_until(first, last, cmp); iter++ != last; )
	return;
}

template<typename Container, typename Compare = std::less<>>
constexpr void make_heap(Container& c, Compare cmp = {})
		noexcept(noexcept(constexprStd::make_heap(std::begin(c), std::end(c), std::move(cmp)))) {
	constexprStd::make_heap(std::begin(c), std::end(c), std::move(cmp));
	return;
}

template<typename RandIter, typename Compare = std::less<>,
         typename Dist = typename std::iterator_traits<RandIter>::difference_type>
constexpr void pop_heap(const RandIter first, RandIter last, Compare cmp)
		noexcept(noexcept(first == last) && noexcept(constexprStd::iter_swap(first, --last)) &&
		         noexcept(constexprStd::distance(first, last)) && std::is_nothrow_move_constructible_v<Dist> &&
		         noexcept(std::declval<const Dist&>() / 2) && std::is_nothrow_constructible_v<Dist, int> &&
		         noexcept(std::declval<Dist&>() < std::declval<const Dist&>()) &&
		         noexcept(std::declval<Dist&>() * 2 + 1) && noexcept(std::declval<const Dist&>() + 1) &&
		         noexcept(constexprStd::next(first, std::declval<const Dist&>())) &&
		         noexcept(cmp(*first, *first)) && noexcept(constexprStd::iter_swap(first, first)) &&
		         std::is_nothrow_copy_assignable_v<Dist>) {
	if ( first == last ) {
		return;
	} //if ( first == last )
	
	constexprStd::iter_swap(first, --last);
	
	const auto n = constexprStd::distance(first, last);
	const auto upperBound = n / 2;
	Dist currentIndex = 0;
	
	while ( currentIndex < upperBound ) {
		const auto leftChildIndex  = currentIndex * 2 + 1;
		const auto rightChildIndex = leftChildIndex + 1;
		const auto current    = constexprStd::next(first, currentIndex);
		const auto leftChild  = constexprStd::next(first, leftChildIndex);
		const auto rightChild = constexprStd::next(first, rightChildIndex);
		
		auto checkAndSwap = [&current,&currentIndex,&cmp,&upperBound](auto& child, const auto& childIndex)
		                    noexcept(noexcept(cmp(*current, *child)) &&
		                    noexcept(constexprStd::iter_swap(current, child)) &&
		                    std::is_nothrow_copy_assignable_v<Dist>) {
				if ( cmp(*current, *child) ) {
					constexprStd::iter_swap(current, child);
					currentIndex = childIndex;
				} //if ( cmp(*current, *child) )
				else {
					currentIndex = upperBound;
				} //else -> if ( cmp(*current, *child) )
				return;
			};
		
		if ( rightChild == last ) {
			//Only one child, eventually swap with it
			checkAndSwap(leftChild, leftChildIndex);
		} //if ( rightChild == last )
		else {
			//Two childs, look for the bigger one
			if ( cmp(*leftChild, *rightChild) ) {
				checkAndSwap(rightChild, rightChildIndex);
			} //if ( cmp(*leftChild, *rightChild) )
			else {
				checkAndSwap(leftChild, leftChildIndex);
			} //else -> if ( cmp(*leftChild, *rightChild) )
		} //else -> if ( rightChild == last )
	} //while ( currentIndex < upperBound )
	return;
}

template<typename RandIter, typename Compare = std::less<>>
constexpr void sort_heap(const RandIter first, RandIter last, Compare cmp)
		noexcept(noexcept(first != last) && noexcept(--last) && noexcept(constexprStd::pop_heap(first, last, cmp))) {
	for ( ; first != last; --last ) {
		constexprStd::pop_heap(first, last, cmp);
	} //for ( ; first != last; --last )
	return;
}

template<typename Container, typename Compare = std::less<>>
constexpr void sort_heap(Container& c, Compare cmp = {})
		noexcept(noexcept(constexprStd::sort_heap(std::begin(c), std::end(c), std::move(cmp)))) {
	constexprStd::sort_heap(std::begin(c), std::end(c), std::move(cmp));
	return;
}

/*****                                        Minimum/Maximum Operations                                          *****/

template<typename InputIter1, typename InputIter2, typename Compare = std::less<>>
constexpr bool lexicographical_compare(InputIter1 first1, const InputIter1 last1,
                                       InputIter2 first2, const InputIter2 last2, Compare comp = Compare{})
noexcept(noexcept(first1 != last1 && first2 != last2) && noexcept(++first1, ++first2) &&
         noexcept(comp(*first1, *first2)) && noexcept(comp(*first2, *first1)) && noexcept(first1 == last1)) {
	for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 ) {
		if ( comp(*first1, *first2) ) {
			return true;
		} //if ( comp(*first1, *first2) )
		if ( comp(*first2, *first1) ) {
			return false;
		} //if ( comp(*first2, *first1) )
	} //for ( ; first1 != last1 && first2 != last2; ++first1, ++first2 )
	return first1 == last1 && (first2 != last2);
}

template<typename Container1, typename Container2, typename Compare = std::less<>>
constexpr bool lexicographical_compare(Container1&& c1, Container2&& c2, Compare comp = Compare{})
		noexcept(noexcept(constexprStd::lexicographical_compare(std::begin(std::forward<Container1>(c1)),
		                                                        std::end(std::forward<Container1>(c1)),
		                                                        std::begin(std::forward<Container2>(c2)),
		                                                        std::end(std::forward<Container2>(c2)),
		                                                        std::move(comp)))) {
	return constexprStd::lexicographical_compare(std::begin(std::forward<Container1>(c1)),
	                                             std::end(std::forward<Container1>(c1)),
	                                             std::begin(std::forward<Container2>(c2)),
	                                             std::end(std::forward<Container2>(c2)), std::move(comp));
}

/*****                                               Permutations                                                 *****/

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr bool is_permutation(ForwardIter1 first1, const ForwardIter1 last1,
                              ForwardIter2 first2, const ForwardIter2 last2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::distance(first1, last1)) && noexcept(constexprStd::distance(first2, last2)) &&
		         noexcept(first1 != last1 && first2 != last2 && pred(*first1, *first2)) &&
		         noexcept(++first1, ++first2) && noexcept(first1 == last1) &&
		         noexcept(std::declval<decltype(constexprStd::distance(first1, last1))>() !=
		                  std::declval<decltype(constexprStd::distance(first2, last2))>()) &&
		         noexcept(std::declval<decltype(constexprStd::distance(first1, last1))>() != 0) &&
		         std::is_nothrow_copy_constructible_v<ForwardIter1> && noexcept(first1 != last1) &&
		         noexcept(++first1) && noexcept(pred(*first1, *first1)) && noexcept(pred(*first2, *first2)) &&
		         noexcept(constexprStd::find_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>())) &&
		         noexcept(constexprStd::count_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>())) &&
		         noexcept(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>())) &&
		         noexcept(std::declval<decltype(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>()))>() == 0) &&
		         noexcept(std::declval<decltype(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>()))>() !=
		                  std::declval<decltype(constexprStd::count_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>()))>())) {
	constexpr bool bothRandomAccess = details::IsRaIter<ForwardIter1>::value && details::IsRaIter<ForwardIter2>::value;
	
	//Compare length for random access, because O(1)
	if constexpr ( bothRandomAccess ) {
		if ( constexprStd::distance(first1, last1) != constexprStd::distance(first2, last2) ) {
			return false;
		} //if ( constexprStd::distance(first1, last1) != constexprStd::distance(first2, last2) )
	} //if constexpr ( bothRandomAccess )
	
	//Search common prefix
	auto mismatchIters = constexprStd::mismatch(first1, last1, first2, last2, pred);
	first1 = mismatchIters.first;
	first2 = mismatchIters.second;
	
	if constexpr ( bothRandomAccess ) {
		if ( first1 == last1 ) {
			//All clear
			return true;
		} //if ( first1 == last1 )
	} //if constexpr ( bothRandomAccess )
	else {
		//Calculate length of remaining ranges
		const auto d1 = constexprStd::distance(first1, last1);
		const auto d2 = constexprStd::distance(first2, last2);
		
		//Can't be a permutation
		if ( d1 != d2 ) {
			return false;
		} //if ( d1 != d2 )
		
		//We have established that d1 == d2, so we only need to check d1
		if ( d1 == 0 ) {
			//Checked complete range, done
			return true;
		} //if ( d1 == 0 )
	} //else -> if constexpr ( bothRandomAccess )
	
	//Now we have to check the real permutation
	for ( auto scan = first1; scan != last1; ++scan ) {
		auto cmpLambda = [&pred,cmp = *scan](const typename std::iterator_traits<ForwardIter2>::value_type& value)
		                 noexcept(noexcept(pred(*scan, value))) {
				return pred(cmp, value);
			};
		
		//Search in [first1,scan) if we already handled this element
		if ( constexprStd::find_if(first1, scan, cmpLambda) != scan ) {
			//We have handled this
			continue;
		} //if ( constexprStd::find_if(first1, scan, cmpLambda) != scan )
		
		const auto matches = constexprStd::count_if(first2, last2, cmpLambda);
		if ( matches == 0 || matches != constexprStd::count_if(scan, last1, cmpLambda) ) {
			return false;
		} //if ( matches == 0 || matches != constexprStd::count_if(scan, last1, cmpLambda) )
	} //for ( auto scan = first1; scan != last1; ++scan )
	return true;
}

template<typename Container1, typename Container2, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool is_permutation(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
		                                               std::end(std::forward<Container1>(c1)),
		                                               std::begin(std::forward<Container2>(c2)),
		                                               std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
	                                    std::end(std::forward<Container1>(c1)),
	                                    std::begin(std::forward<Container2>(c2)),
	                                    std::end(std::forward<Container2>(c2)), pred);
}

template<typename ForwardIter1, typename ForwardIter2>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1,
                              const ForwardIter2 first2, const ForwardIter2 last2)
		noexcept(noexcept(constexprStd::is_permutation(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::is_permutation(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool is_permutation(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
		                                               std::end(std::forward<Container1>(c1)),
		                                               std::begin(std::forward<Container2>(c2)),
		                                               std::end(std::forward<Container2>(c2))))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
	                                    std::end(std::forward<Container1>(c1)),
	                                    std::begin(std::forward<Container2>(c2)),
	                                    std::end(std::forward<Container2>(c2)));
}

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1, const ForwardIter2 first2,
                              const BinaryPredicate pred)
		noexcept(std::is_nothrow_copy_constructible_v<ForwardIter2> &&
		         noexcept(constexprStd::advance(std::declval<ForwardIter2&>(),
		                                        constexprStd::distance(first1, last1))) &&
		         noexcept(constexprStd::is_permutation(first1, last1, first2, std::declval<ForwardIter2&>(), pred))) {
	ForwardIter2 last2 = first2;
	constexprStd::advance(last2, constexprStd::distance(first1, last1));
	return constexprStd::is_permutation(first1, last1, first2, last2, pred);
}

template<typename Container, typename ForwardIter2, typename BinaryPredicate,
         std::enable_if_t<details::IsIterV<ForwardIter2>>* = nullptr>
constexpr bool is_permutation(Container&& c, const ForwardIter2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                    first2, pred);
}

template<typename ForwardIter1, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter1>>* = nullptr>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1, const ForwardIter2 first2)
		noexcept(noexcept(constexprStd::is_permutation(first1, last1, first2, details::cmp::Equal{}))){
	return constexprStd::is_permutation(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter2>>* = nullptr>
constexpr bool is_permutation(Container&& c, const ForwardIter2 first2)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
	                                    std::end(std::forward<Container>(c)), first2);
}
} //namespace constexprStd

#endif
