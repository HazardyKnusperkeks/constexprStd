/**
 ** This file is part of the constexprStd project.
 ** Copyright 2017 Björn Schäpers <bjoern@hazardy.de>.
 **
 ** This program is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as
 ** published by the Free Software Foundation, either version 3 of the
 ** License, or (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file
 * @brief Defines constexpr variants of the <algorithm>.
 */

#ifndef CONSTEXPRSTD_ALGORITHM
#define CONSTEXPRSTD_ALGORITHM

#include <iterator>
#include <type_traits>

#include "details/algorithm.hpp"
#include "functional"
#include "iterator"

namespace constexprStd {
/*****                                     Non-modifying sequence operations                                      *****/
template<typename InputIter, typename UnaryPredicate>
constexpr auto count_if(InputIter first, const InputIter last, const UnaryPredicate pred)
		noexcept(std::is_nothrow_constructible_v<typename std::iterator_traits<InputIter>::difference_type,
		                                         decltype(0)> &&
		         noexcept(first != last) && noexcept(++first) && noexcept(pred(*first)) &&
		         noexcept(++std::declval<typename std::iterator_traits<InputIter>::difference_type&>())) {
	typename std::iterator_traits<InputIter>::difference_type ret = 0;
	for ( ; first != last; ++first ) {
		if ( pred(*first) ) {
			++ret;
		} //if ( pred(*first) )
	} //for ( ; first != last; ++first )
	return ret;
}

template<typename Container, typename UnaryPredicate>
constexpr auto count_if(Container&& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::count_if(std::begin(std::forward<Container>(c)),
		                                         std::end(std::forward<Container>(c)), pred))) {
	return constexprStd::count_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), pred);
}

template<typename InputIter, typename T>
constexpr auto count(const InputIter first, const InputIter last, const T& t)
		noexcept(noexcept(constexprStd::count_if(first, last, details::cmp::EqualToValue{t}))) {
	return constexprStd::count_if(first, last, details::cmp::EqualToValue{t});
}

template<typename Container, typename T>
constexpr auto count(Container&& c, const T& t)
		noexcept(noexcept(constexprStd::count(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), t))) {
	return constexprStd::count(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), t);
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(IterT1 first1, const IterT1 last1, IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(first1 != last1) && noexcept(++first1, ++first2) && noexcept(pred(*first1, *first2))) {
	for ( ; first1 != last1; ++first1, ++first2 ) {
		if ( !pred(*first1, *first2) ) {
			return false;
		} //if ( !pred(*first1, *first2) )
	} //for ( ; first1 != last1; ++first1, ++first2 )
	return true;
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2, details::cmp::Equal{}))) {
	return constexprStd::equal(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename IterT2, typename BinaryPredicate>
constexpr bool equal(Container&& c, const IterT2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::equal(std::begin(std::forward<Container>(c)),
	                           std::end(std::forward<Container>(c)), first2, pred);
}

template<typename Container, typename IterT2, std::enable_if_t<details::IsIterV<IterT2>>* = nullptr>
constexpr bool equal(Container&& c, const IterT2 first2)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container>(c)),
		                                      std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::equal(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), first2);
}

template<typename IterT1, typename IterT2, typename BinaryPredicate>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2,
                     const BinaryPredicate pred)
		noexcept(noexcept(details::equalImpl(first1, last1, first2, last2, pred))) {
	return details::equalImpl(first1, last1, first2, last2, pred);
}

template<typename IterT1, typename IterT2>
constexpr bool equal(const IterT1 first1, const IterT1 last1, const IterT2 first2, const IterT2 last2)
		noexcept(noexcept(constexprStd::equal(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::equal(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2, typename BinaryPredicate>
constexpr bool equal(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container1>(c1)),
		                                      std::end(std::forward<Container1>(c1)),
		                                      std::begin(std::forward<Container2>(c2)),
		                                      std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::equal(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                           std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)), pred);
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool equal(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::equal(std::begin(std::forward<Container1>(c1)),
		                                      std::end(std::forward<Container1>(c1)),
		                                      std::begin(std::forward<Container2>(c2)),
		                                      std::end(std::forward<Container2>(c2))))) {
	return constexprStd::equal(std::begin(std::forward<Container1>(c1)), std::end(std::forward<Container1>(c1)),
	                           std::begin(std::forward<Container2>(c2)), std::end(std::forward<Container2>(c2)));
}

template<typename InputIter, typename UnaryPredicate>
constexpr InputIter find_if(InputIter first, const InputIter last, const UnaryPredicate pred)
		noexcept(noexcept(first != last && !pred(*first)) && noexcept(++first)) {
	for ( ; first != last && !pred(*first); ++first ) {
		
	} //for ( ; first != last && !pred(*first); ++first )
	return first;
}

template<typename Container, typename UnaryPredicate>
constexpr auto find_if(Container&& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), pred))) {
	return constexprStd::find_if(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), pred);
}

template<typename InputIter, typename T>
constexpr InputIter find(const InputIter first, const InputIter last, const T& t)
		noexcept(noexcept(constexprStd::find_if(first, last, details::cmp::EqualToValue{t}))) {
	return constexprStd::find_if(first, last, details::cmp::EqualToValue{t});
}

template<typename Container, typename T>
constexpr auto find(Container&& c, const T& t)
		noexcept(noexcept(constexprStd::find(std::begin(std::forward<Container>(c)),
		                                     std::end(std::forward<Container>(c)), t))) {
	return constexprStd::find(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), t);
}

template<typename InputIter, typename UnaryPredicate>
constexpr InputIter find_if_not(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, constexprStd::not_fn(std::move(pred))))) {
	return constexprStd::find_if(first, last, constexprStd::not_fn(std::move(pred)));
}

template<typename Container, typename UnaryPredicate>
constexpr auto find_if_not(Container&& c, const UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if_not(std::begin(std::forward<Container>(c)),
		                                            std::end(std::forward<Container>(c)), pred))) {
	return constexprStd::find_if_not(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                 pred);
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool all_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if_not(first, last, std::move(pred)) == last)) {
	return constexprStd::find_if_not(first, last, std::move(pred)) == last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool all_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::all_of(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::all_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::move(pred));
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool any_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, std::move(pred)) != last)) {
	return constexprStd::find_if(first, last, std::move(pred)) != last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool any_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::any_of(std::begin(std::forward<Container>(c)),
		                                       std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::any_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                            std::move(pred));
}

template<typename InputIter, typename UnaryPredicate>
constexpr bool none_of(const InputIter first, const InputIter last, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::find_if(first, last, std::move(pred)) == last)) {
	return constexprStd::find_if(first, last, std::move(pred)) == last;
}

template<typename Container, typename UnaryPredicate>
constexpr bool none_of(Container&& c, UnaryPredicate pred)
		noexcept(noexcept(constexprStd::none_of(std::begin(std::forward<Container>(c)),
		                                        std::end(std::forward<Container>(c)), std::move(pred)))) {
	return constexprStd::none_of(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                             std::move(pred));
}

/*****                                       Modifying sequence operations                                        *****/

template<typename InputIterator, typename OutputIterator>
constexpr OutputIterator copy(InputIterator sourceFirst, const InputIterator sourceLast, OutputIterator destination)
		noexcept(noexcept(sourceFirst != sourceLast) && noexcept(++sourceFirst) && noexcept(++destination) &&
		         noexcept(*destination = *sourceFirst)) {
	for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination ) {
		*destination = *sourceFirst;
	} //for ( ; sourceFirst != sourceLast; ++sourceFirst, ++destination )
	return destination;
}

template<typename Container, typename OutputIterator>
constexpr OutputIterator copy(Container&& c, OutputIterator destination)
		noexcept(noexcept(copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
		                       destination))) {
	return copy(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)), destination);
}

/*****                                               Permutations                                                 *****/

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr bool is_permutation(ForwardIter1 first1, const ForwardIter1 last1,
                              ForwardIter2 first2, const ForwardIter2 last2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::distance(first1, last1)) && noexcept(constexprStd::distance(first2, last2)) &&
		         noexcept(first1 != last1 && first2 != last2 && pred(*first1, *first2)) &&
		         noexcept(++first1, ++first2) && noexcept(first1 == last1) &&
		         noexcept(std::declval<decltype(constexprStd::distance(first1, last1))>() !=
		                  std::declval<decltype(constexprStd::distance(first2, last2))>()) &&
		         noexcept(std::declval<decltype(constexprStd::distance(first1, last1))>() != 0) &&
		         std::is_nothrow_copy_constructible_v<ForwardIter1> && noexcept(first1 != last1) &&
		         noexcept(++first1) && noexcept(pred(*first1, *first1)) && noexcept(pred(*first2, *first2)) &&
		         noexcept(constexprStd::find_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>())) &&
		         noexcept(constexprStd::count_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>())) &&
		         noexcept(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>())) &&
		         noexcept(std::declval<decltype(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>()))>() == 0) &&
		         noexcept(std::declval<decltype(constexprStd::count_if(first2, last2, std::declval<bool(decltype(*first2)) noexcept>()))>() !=
		                  std::declval<decltype(constexprStd::count_if(first1, last1, std::declval<bool(decltype(*first1)) noexcept>()))>())) {
	constexpr bool bothRandomAccess = details::IsRaIter<ForwardIter1>::value && details::IsRaIter<ForwardIter2>::value;
	
	//Compare length for random access, because O(1)
	if constexpr ( bothRandomAccess ) {
		if ( constexprStd::distance(first1, last1) != constexprStd::distance(first2, last2) ) {
			return false;
		} //if ( constexprStd::distance(first1, last1) != constexprStd::distance(first2, last2) )
	} //if constexpr ( bothRandomAccess )
	
	//Search common prefix
	for ( ; first1 != last1 && first2 != last2 && pred(*first1, *first2); ++first1, ++first2 ) {
		
	} //for ( ; first1 != last1 && first2 != last2 && pred(*first1, *first2); ++first1, ++first2 )
	
	if constexpr ( bothRandomAccess ) {
		if ( first1 == last1 ) {
			//All clear
			return true;
		} //if ( first1 == last1 )
	} //if constexpr ( bothRandomAccess )
	else {
		//Calculate length of remaining ranges
		const auto d1 = constexprStd::distance(first1, last1);
		const auto d2 = constexprStd::distance(first2, last2);
		
		//Can't be a permutation
		if ( d1 != d2 ) {
			return false;
		} //if ( d1 != d2 )
		
		//We have established that d1 == d2, so we only need to check d1
		if ( d1 == 0 ) {
			//Checked complete range, done
			return true;
		} //if ( d1 == 0 )
	} //else -> if constexpr ( bothRandomAccess )
	
	//Now we have to check the real permutation
	for ( auto scan = first1; scan != last1; ++scan ) {
		auto cmpLambda = [&pred,cmp = *scan](const typename std::iterator_traits<ForwardIter2>::value_type& value)
		                 noexcept(noexcept(pred(*scan, value))) {
				return pred(cmp, value);
			};
		
		//Search in [first1,scan) if we already handled this element
		if ( constexprStd::find_if(first1, scan, cmpLambda) != scan ) {
			//We have handled this
			continue;
		} //if ( constexprStd::find_if(first1, scan, cmpLambda) != scan )
		
		const auto matches = constexprStd::count_if(first2, last2, cmpLambda);
		if ( matches == 0 || matches != constexprStd::count_if(scan, last1, cmpLambda) ) {
			return false;
		} //if ( matches == 0 || matches != constexprStd::count_if(scan, last1, cmpLambda) )
	} //for ( auto scan = first1; scan != last1; ++scan )
	return true;
}

template<typename Container1, typename Container2, typename BinaryPredicate,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool is_permutation(Container1&& c1, Container2&& c2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
		                                               std::end(std::forward<Container1>(c1)),
		                                               std::begin(std::forward<Container2>(c2)),
		                                               std::end(std::forward<Container2>(c2)), pred))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
	                                    std::end(std::forward<Container1>(c1)),
	                                    std::begin(std::forward<Container2>(c2)),
	                                    std::end(std::forward<Container2>(c2)), pred);
}

template<typename ForwardIter1, typename ForwardIter2>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1,
                              const ForwardIter2 first2, const ForwardIter2 last2)
		noexcept(noexcept(constexprStd::is_permutation(first1, last1, first2, last2, details::cmp::Equal{}))) {
	return constexprStd::is_permutation(first1, last1, first2, last2, details::cmp::Equal{});
}

template<typename Container1, typename Container2,
         std::enable_if_t<std::negation_v<details::IsIter<Container2>>>* = nullptr>
constexpr bool is_permutation(Container1&& c1, Container2&& c2)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
		                                               std::end(std::forward<Container1>(c1)),
		                                               std::begin(std::forward<Container2>(c2)),
		                                               std::end(std::forward<Container2>(c2))))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container1>(c1)),
	                                    std::end(std::forward<Container1>(c1)),
	                                    std::begin(std::forward<Container2>(c2)),
	                                    std::end(std::forward<Container2>(c2)));
}

template<typename ForwardIter1, typename ForwardIter2, typename BinaryPredicate>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1, const ForwardIter2 first2,
                              const BinaryPredicate pred)
		noexcept(std::is_nothrow_copy_constructible_v<ForwardIter2> &&
		         noexcept(constexprStd::advance(std::declval<ForwardIter2&>(),
		                                        constexprStd::distance(first1, last1))) &&
		         noexcept(constexprStd::is_permutation(first1, last1, first2, std::declval<ForwardIter2&>(), pred))) {
	ForwardIter2 last2 = first2;
	constexprStd::advance(last2, constexprStd::distance(first1, last1));
	return constexprStd::is_permutation(first1, last1, first2, last2, pred);
}

template<typename Container, typename ForwardIter2, typename BinaryPredicate,
         std::enable_if_t<details::IsIterV<ForwardIter2>>* = nullptr>
constexpr bool is_permutation(Container&& c, const ForwardIter2 first2, const BinaryPredicate pred)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), first2, pred))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container>(c)), std::end(std::forward<Container>(c)),
	                                    first2, pred);
}

template<typename ForwardIter1, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter1>>* = nullptr>
constexpr bool is_permutation(const ForwardIter1 first1, const ForwardIter1 last1, const ForwardIter2 first2)
		noexcept(noexcept(constexprStd::is_permutation(first1, last1, first2, details::cmp::Equal{}))){
	return constexprStd::is_permutation(first1, last1, first2, details::cmp::Equal{});
}

template<typename Container, typename ForwardIter2, std::enable_if_t<details::IsIterV<ForwardIter2>>* = nullptr>
constexpr bool is_permutation(Container&& c, const ForwardIter2 first2)
		noexcept(noexcept(constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
		                                               std::end(std::forward<Container>(c)), first2))) {
	return constexprStd::is_permutation(std::begin(std::forward<Container>(c)),
	                                    std::end(std::forward<Container>(c)), first2);
}
} //namespace constexprStd

#endif
